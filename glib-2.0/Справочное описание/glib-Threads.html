<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>
Threads</title>
<meta name="generator" content="DocBook XSL Stylesheets V1.68.1">
<link rel="start" href="index.html" title="GLib Reference Manual">
<link rel="up" href="glib-core.html" title="GLib Core Application Support">
<link rel="prev" href="glib-The-Main-Event-Loop.html" title="The Main Event Loop">
<link rel="next" href="glib-Thread-Pools.html" title="Thread Pools">
<meta name="generator" content="GTK-Doc V1.7 (XML mode)">
<link rel="stylesheet" href="style.css" type="text/css">
<link rel="chapter" href="glib.html" title="GLib Overview">
<link rel="chapter" href="glib-fundamentals.html" title="GLib Fundamentals">
<link rel="chapter" href="glib-core.html" title="GLib Core Application Support">
<link rel="chapter" href="glib-utilities.html" title="GLib Utilities">
<link rel="chapter" href="glib-data-types.html" title="GLib Data Types">
<link rel="chapter" href="tools.html" title="GLib Tools">
<link rel="index" href="ix01.html" title="Index">
<link rel="index" href="ix02.html" title="Index of deprecated symbols">
<link rel="index" href="ix03.html" title="Index of new symbols in 2.2">
<link rel="index" href="ix04.html" title="Index of new symbols in 2.4">
<link rel="index" href="ix05.html" title="Index of new symbols in 2.6">
<link rel="index" href="ix06.html" title="Index of new symbols in 2.8">
<link rel="index" href="ix07.html" title="Index of new symbols in 2.10">
<link rel="index" href="ix08.html" title="Index of new symbols in 2.12">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table class="navigation" id="top" width="100%" summary="Navigation header" cellpadding="2" cellspacing="2">
<tr valign="middle">
<td><a accesskey="p" href="glib-The-Main-Event-Loop.html"><img src="left.png" width="24" height="24" border="0" alt="Prev"></a></td>
<td><a accesskey="u" href="glib-core.html"><img src="up.png" width="24" height="24" border="0" alt="Up"></a></td>
<td><a accesskey="h" href="index.html"><img src="home.png" width="24" height="24" border="0" alt="Home"></a></td>
<th width="100%" align="center">Справочное описание GLib</th>
<td><a accesskey="n" href="glib-Thread-Pools.html"><img src="right.png" width="24" height="24" border="0" alt="Next"></a></td>
</tr>
<tr><td colspan="5" class="shortcuts"><nobr><a href="#id2584751" class="shortcut">Начало</a>
                  &#160;|&#160;
                  <a href="#id2586267" class="shortcut">Описание</a></nobr></td></tr>
</table>
<div class="refentry" lang="en">
<a name="glib-Threads"></a><div class="titlepage"></div>
<div class="refnamediv"><table width="100%"><tr>
<td valign="top">
<h2>
<a name="id2584751"></a><span class="refentrytitle">
Потоки</span>
</h2>
<p>
Threads &#8212; 
Абстракция потока; включает потоки, различные взаимоисключения (mutexes), условия и поток закрытых данных.</p>
</td>
<td valign="top" align="right"></td>
</tr></table></div>
<div class="refsynopsisdiv">
<h2>Краткое описание</h2>
<pre class="synopsis">

#include &lt;glib.h&gt;



#define     <a href="glib-Threads.html#G-THREADS-ENABLED:CAPS">G_THREADS_ENABLED</a>
#define     <a href="glib-Threads.html#G-THREADS-IMPL-POSIX:CAPS">G_THREADS_IMPL_POSIX</a>
#define     <a href="glib-Threads.html#G-THREADS-IMPL-NONE:CAPS">G_THREADS_IMPL_NONE</a>

#define     <a href="glib-Threads.html#G-THREAD-ERROR:CAPS">G_THREAD_ERROR</a>
enum        <a href="glib-Threads.html#GThreadError">GThreadError</a>;

            <a href="glib-Threads.html#GThreadFunctions">GThreadFunctions</a>;
void        <a href="glib-Threads.html#g-thread-init">g_thread_init</a>                   (<a href="glib-Threads.html#GThreadFunctions">GThreadFunctions</a> *vtable);
<a href="glib-Basic-Types.html#gboolean">gboolean</a>    <a href="glib-Threads.html#g-thread-supported">g_thread_supported</a>              ();

<a href="glib-Basic-Types.html#gpointer">gpointer</a>    (<a href="glib-Threads.html#GThreadFunc">*GThreadFunc</a>)                  (<a href="glib-Basic-Types.html#gpointer">gpointer</a> data);
enum        <a href="glib-Threads.html#GThreadPriority">GThreadPriority</a>;
            <a href="glib-Threads.html#GThread">GThread</a>;
<a href="glib-Threads.html#GThread">GThread</a>*    <a href="glib-Threads.html#g-thread-create">g_thread_create</a>                 (<a href="glib-Threads.html#GThreadFunc">GThreadFunc</a> func,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> data,
                                             <a href="glib-Basic-Types.html#gboolean">gboolean</a> joinable,
                                             <a href="glib-Error-Reporting.html#GError">GError</a> **error);
<a href="glib-Threads.html#GThread">GThread</a>*    <a href="glib-Threads.html#g-thread-create-full">g_thread_create_full</a>            (<a href="glib-Threads.html#GThreadFunc">GThreadFunc</a> func,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> data,
                                             <a href="glib-Basic-Types.html#gulong">gulong</a> stack_size,
                                             <a href="glib-Basic-Types.html#gboolean">gboolean</a> joinable,
                                             <a href="glib-Basic-Types.html#gboolean">gboolean</a> bound,
                                             <a href="glib-Threads.html#GThreadPriority">GThreadPriority</a> priority,
                                             <a href="glib-Error-Reporting.html#GError">GError</a> **error);
<a href="glib-Threads.html#GThread">GThread</a>*    <a href="glib-Threads.html#g-thread-self">g_thread_self</a>                   (void);
<a href="glib-Basic-Types.html#gpointer">gpointer</a>    <a href="glib-Threads.html#g-thread-join">g_thread_join</a>                   (<a href="glib-Threads.html#GThread">GThread</a> *thread);
void        <a href="glib-Threads.html#g-thread-set-priority">g_thread_set_priority</a>           (<a href="glib-Threads.html#GThread">GThread</a> *thread,
                                             <a href="glib-Threads.html#GThreadPriority">GThreadPriority</a> priority);
void        <a href="glib-Threads.html#g-thread-yield">g_thread_yield</a>                  ();
void        <a href="glib-Threads.html#g-thread-exit">g_thread_exit</a>                   (<a href="glib-Basic-Types.html#gpointer">gpointer</a> retval);
void        <a href="glib-Threads.html#g-thread-foreach">g_thread_foreach</a>                (<a href="glib-Doubly-Linked-Lists.html#GFunc">GFunc</a> thread_func,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> user_data);

            <a href="glib-Threads.html#GMutex">GMutex</a>;
<a href="glib-Threads.html#GMutex">GMutex</a>*     <a href="glib-Threads.html#g-mutex-new">g_mutex_new</a>                     ();
void        <a href="glib-Threads.html#g-mutex-lock">g_mutex_lock</a>                    (<a href="glib-Threads.html#GMutex">GMutex</a> *mutex);
<a href="glib-Basic-Types.html#gboolean">gboolean</a>    <a href="glib-Threads.html#g-mutex-trylock">g_mutex_trylock</a>                 (<a href="glib-Threads.html#GMutex">GMutex</a> *mutex);
void        <a href="glib-Threads.html#g-mutex-unlock">g_mutex_unlock</a>                  (<a href="glib-Threads.html#GMutex">GMutex</a> *mutex);
void        <a href="glib-Threads.html#g-mutex-free">g_mutex_free</a>                    (<a href="glib-Threads.html#GMutex">GMutex</a> *mutex);

            <a href="glib-Threads.html#GStaticMutex">GStaticMutex</a>;
#define     <a href="glib-Threads.html#G-STATIC-MUTEX-INIT:CAPS">G_STATIC_MUTEX_INIT</a>
void        <a href="glib-Threads.html#g-static-mutex-init">g_static_mutex_init</a>             (<a href="glib-Threads.html#GStaticMutex">GStaticMutex</a> *mutex);
void        <a href="glib-Threads.html#g-static-mutex-lock">g_static_mutex_lock</a>             (<a href="glib-Threads.html#GStaticMutex">GStaticMutex</a> *mutex);
<a href="glib-Basic-Types.html#gboolean">gboolean</a>    <a href="glib-Threads.html#g-static-mutex-trylock">g_static_mutex_trylock</a>          (<a href="glib-Threads.html#GStaticMutex">GStaticMutex</a> *mutex);
void        <a href="glib-Threads.html#g-static-mutex-unlock">g_static_mutex_unlock</a>           (<a href="glib-Threads.html#GStaticMutex">GStaticMutex</a> *mutex);
<a href="glib-Threads.html#GMutex">GMutex</a>*     <a href="glib-Threads.html#g-static-mutex-get-mutex">g_static_mutex_get_mutex</a>        (<a href="glib-Threads.html#GStaticMutex">GStaticMutex</a> *mutex);
void        <a href="glib-Threads.html#g-static-mutex-free">g_static_mutex_free</a>             (<a href="glib-Threads.html#GStaticMutex">GStaticMutex</a> *mutex);

#define     <a href="glib-Threads.html#G-LOCK-DEFINE:CAPS">G_LOCK_DEFINE</a>                   (name)
#define     <a href="glib-Threads.html#G-LOCK-DEFINE-STATIC:CAPS">G_LOCK_DEFINE_STATIC</a>            (name)
#define     <a href="glib-Threads.html#G-LOCK-EXTERN:CAPS">G_LOCK_EXTERN</a>                   (name)
#define     <a href="glib-Threads.html#G-LOCK:CAPS">G_LOCK</a>                          (name)
#define     <a href="glib-Threads.html#G-TRYLOCK:CAPS">G_TRYLOCK</a>                       (name)
#define     <a href="glib-Threads.html#G-UNLOCK:CAPS">G_UNLOCK</a>                        (name)

            <a href="glib-Threads.html#GStaticRecMutex">GStaticRecMutex</a>;
#define     <a href="glib-Threads.html#G-STATIC-REC-MUTEX-INIT:CAPS">G_STATIC_REC_MUTEX_INIT</a>
void        <a href="glib-Threads.html#g-static-rec-mutex-init">g_static_rec_mutex_init</a>         (<a href="glib-Threads.html#GStaticRecMutex">GStaticRecMutex</a> *mutex);
void        <a href="glib-Threads.html#g-static-rec-mutex-lock">g_static_rec_mutex_lock</a>         (<a href="glib-Threads.html#GStaticRecMutex">GStaticRecMutex</a> *mutex);
<a href="glib-Basic-Types.html#gboolean">gboolean</a>    <a href="glib-Threads.html#g-static-rec-mutex-trylock">g_static_rec_mutex_trylock</a>      (<a href="glib-Threads.html#GStaticRecMutex">GStaticRecMutex</a> *mutex);
void        <a href="glib-Threads.html#g-static-rec-mutex-unlock">g_static_rec_mutex_unlock</a>       (<a href="glib-Threads.html#GStaticRecMutex">GStaticRecMutex</a> *mutex);
void        <a href="glib-Threads.html#g-static-rec-mutex-lock-full">g_static_rec_mutex_lock_full</a>    (<a href="glib-Threads.html#GStaticRecMutex">GStaticRecMutex</a> *mutex,
                                             <a href="glib-Basic-Types.html#guint">guint</a> depth);
<a href="glib-Basic-Types.html#guint">guint</a>       <a href="glib-Threads.html#g-static-rec-mutex-unlock-full">g_static_rec_mutex_unlock_full</a>  (<a href="glib-Threads.html#GStaticRecMutex">GStaticRecMutex</a> *mutex);
void        <a href="glib-Threads.html#g-static-rec-mutex-free">g_static_rec_mutex_free</a>         (<a href="glib-Threads.html#GStaticRecMutex">GStaticRecMutex</a> *mutex);

            <a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a>;
#define     <a href="glib-Threads.html#G-STATIC-RW-LOCK-INIT:CAPS">G_STATIC_RW_LOCK_INIT</a>
void        <a href="glib-Threads.html#g-static-rw-lock-init">g_static_rw_lock_init</a>           (<a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a> *lock);
void        <a href="glib-Threads.html#g-static-rw-lock-reader-lock">g_static_rw_lock_reader_lock</a>    (<a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a> *lock);
<a href="glib-Basic-Types.html#gboolean">gboolean</a>    <a href="glib-Threads.html#g-static-rw-lock-reader-trylock">g_static_rw_lock_reader_trylock</a> (<a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a> *lock);
void        <a href="glib-Threads.html#g-static-rw-lock-reader-unlock">g_static_rw_lock_reader_unlock</a>  (<a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a> *lock);
void        <a href="glib-Threads.html#g-static-rw-lock-writer-lock">g_static_rw_lock_writer_lock</a>    (<a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a> *lock);
<a href="glib-Basic-Types.html#gboolean">gboolean</a>    <a href="glib-Threads.html#g-static-rw-lock-writer-trylock">g_static_rw_lock_writer_trylock</a> (<a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a> *lock);
void        <a href="glib-Threads.html#g-static-rw-lock-writer-unlock">g_static_rw_lock_writer_unlock</a>  (<a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a> *lock);
void        <a href="glib-Threads.html#g-static-rw-lock-free">g_static_rw_lock_free</a>           (<a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a> *lock);

            <a href="glib-Threads.html#GCond">GCond</a>;
<a href="glib-Threads.html#GCond">GCond</a>*      <a href="glib-Threads.html#g-cond-new">g_cond_new</a>                      ();
void        <a href="glib-Threads.html#g-cond-signal">g_cond_signal</a>                   (<a href="glib-Threads.html#GCond">GCond</a> *cond);
void        <a href="glib-Threads.html#g-cond-broadcast">g_cond_broadcast</a>                (<a href="glib-Threads.html#GCond">GCond</a> *cond);
void        <a href="glib-Threads.html#g-cond-wait">g_cond_wait</a>                     (<a href="glib-Threads.html#GCond">GCond</a> *cond,
                                             <a href="glib-Threads.html#GMutex">GMutex</a> *mutex);
<a href="glib-Basic-Types.html#gboolean">gboolean</a>    <a href="glib-Threads.html#g-cond-timed-wait">g_cond_timed_wait</a>               (<a href="glib-Threads.html#GCond">GCond</a> *cond,
                                             <a href="glib-Threads.html#GMutex">GMutex</a> *mutex,
                                             <a href="glib-Date-and-Time-Functions.html#GTimeVal">GTimeVal</a> *abs_time);
void        <a href="glib-Threads.html#g-cond-free">g_cond_free</a>                     (<a href="glib-Threads.html#GCond">GCond</a> *cond);

            <a href="glib-Threads.html#GPrivate">GPrivate</a>;
<a href="glib-Threads.html#GPrivate">GPrivate</a>*   <a href="glib-Threads.html#g-private-new">g_private_new</a>                   (<a href="glib-Datasets.html#GDestroyNotify">GDestroyNotify</a> destructor);
<a href="glib-Basic-Types.html#gpointer">gpointer</a>    <a href="glib-Threads.html#g-private-get">g_private_get</a>                   (<a href="glib-Threads.html#GPrivate">GPrivate</a> *private_key);
void        <a href="glib-Threads.html#g-private-set">g_private_set</a>                   (<a href="glib-Threads.html#GPrivate">GPrivate</a> *private_key,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> data);

            <a href="glib-Threads.html#GStaticPrivate">GStaticPrivate</a>;
#define     <a href="glib-Threads.html#G-STATIC-PRIVATE-INIT:CAPS">G_STATIC_PRIVATE_INIT</a>
void        <a href="glib-Threads.html#g-static-private-init">g_static_private_init</a>           (<a href="glib-Threads.html#GStaticPrivate">GStaticPrivate</a> *private_key);
<a href="glib-Basic-Types.html#gpointer">gpointer</a>    <a href="glib-Threads.html#g-static-private-get">g_static_private_get</a>            (<a href="glib-Threads.html#GStaticPrivate">GStaticPrivate</a> *private_key);
void        <a href="glib-Threads.html#g-static-private-set">g_static_private_set</a>            (<a href="glib-Threads.html#GStaticPrivate">GStaticPrivate</a> *private_key,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> data,
                                             <a href="glib-Datasets.html#GDestroyNotify">GDestroyNotify</a> notify);
void        <a href="glib-Threads.html#g-static-private-free">g_static_private_free</a>           (<a href="glib-Threads.html#GStaticPrivate">GStaticPrivate</a> *private_key);

            <a href="glib-Threads.html#GOnce">GOnce</a>;
enum        <a href="glib-Threads.html#GOnceStatus">GOnceStatus</a>;
#define     <a href="glib-Threads.html#G-ONCE-INIT:CAPS">G_ONCE_INIT</a>
#define     <a href="glib-Threads.html#g-once">g_once</a>                          (once, func, arg)

</pre>
</div>
<div class="refsect1" lang="en">
<a name="id2586267"></a><h2>Описание</h2>
<p>
Потоки действуют почти как процессы, но в отличии от процессов все потоки
одного процесса совместно используют одну и туже память. Это хорошо, поскольку 
обеспечивает простую взаимосвязь между вовлечёнными потоками через общую память,
и это плохо, потому что могут происходить странные вещи (так называемый "Heisenbugs") 
если программа спроектирована не достаточно внимательно. В частности из-за параллельной
природы потоков, выполняемый код не может выполняться в разных потоках, если программист 
явно не назначил это через синхронизацию примитивов.
</p>
<p>
Цель связанных с потоком функций в GLib заключается в обеспечении переносимого способа
создания многопоточных программ. Есть примитивы для взаимоисключений для защиты доступа 
к участкам памяти 
(<a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a>, <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>, <a href="glib-Threads.html#G-LOCK-DEFINE:CAPS"><span class="type">G_LOCK_DEFINE</span></a>, <a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a> и
<a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a>). 
Есть примитивы для переменных условий позволяющие синхронизацию потоков 
(<a href="glib-Threads.html#GCond"><span class="type">GCond</span></a>). Есть примитивы для закрытых
 потоковых данных - данных, закрытый экземпляр которых имеет каждый поток
(<a href="glib-Threads.html#GPrivate"><span class="type">GPrivate</span></a>, <a href="glib-Threads.html#GStaticPrivate"><span class="type">GStaticPrivate</span></a>). И не в последнюю очередь есть 
примитивы для портативного создания и управления потоками (<a href="glib-Threads.html#GThread"><span class="type">GThread</span></a>).
</p>
<p>
Вы должны вызывать <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> 
перед выполнением любых других функций GLib в потоковых GLib программах. После этого, 
GLib полностью потоко-безопасен (все глобальные данные автоматически блокируются), но 
индивидуальные экземпляры структур данных не блокируются автоматически по причине выполнения. 
Поэтому, например вы должны координировать доступ к одной и той же 
<a href="glib-Hash-Tables.html#GHashTable"><span class="type">GHashTable</span></a> 
из множества потоков. Известно два исключения из этого правила 
<a href="glib-The-Main-Event-Loop.html#GMainLoop"><span class="type">GMainLoop</span></a> и <a href="glib-Asynchronous-Queues.html#GAsyncQueue"><span class="type">GAsyncQueue</span></a>,
которые <span class="emphasis"><em>являются</em></span> потоко-безопасными и не нуждаются в 
дальнейшей блокировки на уровне приложения для доступности из множества потоков.
</p>
</div>
<div class="refsect1" lang="en">
<a name="id2586426"></a><h2>Детали</h2>
<div class="refsect2" lang="en">
<a name="id2586436"></a><h3>
<a name="G-THREADS-ENABLED:CAPS"></a>G_THREADS_ENABLED</h3>
<a class="indexterm" name="id2586449"></a><pre class="programlisting">#define G_THREADS_ENABLED
</pre>
<p>
Этот макрос определяется если GLib была скомпилирована с поддержкой потоков. Это не означает 
обязательную доступность реализации потоков, но это значит что необходимая инфраструктура на месте 
и как только вы обеспечите реализацию потоков в 
<a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a>, 
GLib станет потоко-безопасной. Если <a href="glib-Threads.html#G-THREADS-ENABLED:CAPS"><span class="type">G_THREADS_ENABLED</span></a> не определён, то Glib не может быть безопасной для много-поточности.
</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2586490"></a><h3>
<a name="G-THREADS-IMPL-POSIX:CAPS"></a>G_THREADS_IMPL_POSIX</h3>
<a class="indexterm" name="id2586503"></a><pre class="programlisting">#define G_THREADS_IMPL_POSIX
</pre>
<p>
Этот макрос определяется если используется стиль потоков  POSIX.
</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2586519"></a><h3>
<a name="G-THREADS-IMPL-NONE:CAPS"></a>G_THREADS_IMPL_NONE</h3>
<a class="indexterm" name="id2586533"></a><pre class="programlisting">#define G_THREADS_IMPL_NONE
</pre>
<p>
Этот макрос определяется если нет используемой реализации потоков. Вы можете однако обеспечить это 
с помощью <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> для создания безопасной много-поточности GLib.
</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2586561"></a><h3>
<a name="G-THREAD-ERROR:CAPS"></a>G_THREAD_ERROR</h3>
<a class="indexterm" name="id2586573"></a><pre class="programlisting">#define G_THREAD_ERROR g_thread_error_quark ()
</pre>
<p>
Область ошибок в подсистеме потоков GLib.
</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2586590"></a><h3>
<a name="GThreadError"></a>enum GThreadError</h3>
<a class="indexterm" name="id2586603"></a><pre class="programlisting">typedef enum
{
  G_THREAD_ERROR_AGAIN /* Ресурс временно не доступен */
} GThreadError;
</pre>
<p>
Возможные ошибки связанные с функциями потока.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><a name="G-THREAD-ERROR-AGAIN:CAPS"></a><code class="literal">G_THREAD_ERROR_AGAIN</code></span></td>
<td>поток не создан из-за нехватки ресурсов. Попробуйте повторить попытку позже.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2586648"></a><h3>
<a name="GThreadFunctions"></a>GThreadFunctions</h3>
<a class="indexterm" name="id2586660"></a><pre class="programlisting">typedef struct {
  GMutex*  (*mutex_new)           (void);
  void     (*mutex_lock)          (GMutex               *mutex);
  gboolean (*mutex_trylock)       (GMutex               *mutex);
  void     (*mutex_unlock)        (GMutex               *mutex);
  void     (*mutex_free)          (GMutex               *mutex);
  GCond*   (*cond_new)            (void);
  void     (*cond_signal)         (GCond                *cond);
  void     (*cond_broadcast)      (GCond                *cond);
  void     (*cond_wait)           (GCond                *cond,
                                   GMutex               *mutex);
  gboolean (*cond_timed_wait)     (GCond                *cond,
                                   GMutex               *mutex,
                                   GTimeVal             *end_time);
  void      (*cond_free)          (GCond                *cond);
  GPrivate* (*private_new)        (GDestroyNotify        destructor);
  gpointer  (*private_get)        (GPrivate             *private_key);
  void      (*private_set)        (GPrivate             *private_key,
                                   gpointer              data);
  void      (*thread_create)      (GThreadFunc           func,
                                   gpointer              data,
                                   gulong                stack_size,
                                   gboolean              joinable,
                                   gboolean              bound,
                                   GThreadPriority       priority,
                                   gpointer              thread,
                                   GError              **error);
  void      (*thread_yield)       (void);
  void      (*thread_join)        (gpointer              thread);
  void      (*thread_exit)        (void);
  void      (*thread_set_priority)(gpointer              thread,
                                   GThreadPriority       priority);
  void      (*thread_self)        (gpointer              thread);
  gboolean  (*thread_equal)       (gpointer              thread1,
				   gpointer              thread2);
} GThreadFunctions;
</pre>
<p>
Эта таблица функций используется <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> для инициализации системы потоков. 
Функции в таблице непосредственно используются их копиями с предустановленным в названиях g_* (описаны в данном документе).  Например, если вы вызвали <a href="glib-Threads.html#g-mutex-new"><code class="function">g_mutex_new()</code></a>, тогда будет вызвана <code class="function">mutex_new()</code> 
из таблицы <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a>.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Не используйте эту структуры если не уверены в том что делаете.
</p>
</div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2586802"></a><h3>
<a name="g-thread-init"></a>g_thread_init ()</h3>
<a class="indexterm" name="id2586814"></a><pre class="programlisting">void        g_thread_init                   (<a href="glib-Threads.html#GThreadFunctions">GThreadFunctions</a> *vtable);</pre>
<p>
Если вы используете GLib из более одного потока, вы должны инициализировать систему потоков 
вызовом <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a>. В основном вам нужно вызывать <code class="literal">g_thread_init (NULL)</code>. 
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Не вызывайте <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> 
с не-<a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a> параметром если не уверены в том что делаете.
</p>
</div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
<a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> не должна вызываться непосредственно или косвенно как callback из GLib. Также взаимоисключения не могут 
блокироваться в течении вызова <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a>.
</p>
</div>
<p>
<a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> 
можно вызвать только один раз. Второй вызов вернёт ошибку. Если вы хотите убедиться в том что 
система потоков инициализирована, вы можете сделать следующее:
</p>
<p>
</p>
<div class="informalexample"><pre class="programlisting">
if (!g_thread_supported ()) g_thread_init (NULL);
</pre></div>
<p>
</p>
<p>
После этой команды либо инициализируется система потоков либо, ели нет доступной системы потоков в 
GLib (то есть либо <a href="glib-Threads.html#G-THREADS-ENABLED:CAPS"><span class="type">G_THREADS_ENABLED</span></a> не определён, либо определён <a href="glib-Threads.html#G-THREADS-IMPL-NONE:CAPS"><span class="type">G_THREADS_IMPL_NONE</span></a>), программа будет отменена.
</p>
<p>
Если нет доступной системы потоков и параметр <em class="parameter"><code>vtable</code></em> равен <a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a>, или если не все элементы <em class="parameter"><code>vtable</code></em> являются не-<a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a>, то <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> будет отменён.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Для использования <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> в вашей программе, вы должны привязаться к библиотекам которые выдаёт команда 
<span><strong class="command">pkg-config --libs gthread-2.0</strong></span>. 
Это не касается остальных связанных с потоками функций GLib. Они могут использоваться без привязки 
к потоковым библиотекам.
</p>
</div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>vtable</code></em>&#160;:</span></td>
<td>таблица функций типа <a href="glib-Threads.html#GThreadFunctions"><span class="type">GThreadFunctions</span></a>, которые обеспечивают точки входа в используемую систему потоков.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2587078"></a><h3>
<a name="g-thread-supported"></a>g_thread_supported ()</h3>
<a class="indexterm" name="id2587091"></a><pre class="programlisting"><a href="glib-Basic-Types.html#gboolean">gboolean</a>    g_thread_supported              ();</pre>
<p>
Эта функция возвращает <a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a> если система потоков инициализирована, а
<a href="glib-Standard-Macros.html#FALSE:CAPS"><code class="literal">FALSE</code></a> если нет.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Эта функция является фактически макрокомандой. Однако, кроме захвата адреса её можно использовать как функуию.
</p>
</div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>
<a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>, если система потоков инициализирована.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2587166"></a><h3>
<a name="GThreadFunc"></a>GThreadFunc ()</h3>
<a class="indexterm" name="id2587179"></a><pre class="programlisting"><a href="glib-Basic-Types.html#gpointer">gpointer</a>    (*GThreadFunc)                  (<a href="glib-Basic-Types.html#gpointer">gpointer</a> data);</pre>
<p>
Определяет тип функций <em class="parameter"><code>func</code></em> помещаемых в 
<a href="glib-Threads.html#g-thread-create"><code class="function">g_thread_create()</code></a> или 
<a href="glib-Threads.html#g-thread-create-full"><code class="function">g_thread_create_full()</code></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>data</code></em>&#160;:</span></td>
<td>данные помещаемые в поток.
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>значение возвращаемое потоком, которое будет возвращено 
<a href="glib-Threads.html#g-thread-join"><code class="function">g_thread_join()</code></a>.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2587276"></a><h3>
<a name="GThreadPriority"></a>enum GThreadPriority</h3>
<a class="indexterm" name="id2587289"></a><pre class="programlisting">typedef enum
{
  G_THREAD_PRIORITY_LOW,
  G_THREAD_PRIORITY_NORMAL,
  G_THREAD_PRIORITY_HIGH,
  G_THREAD_PRIORITY_URGENT
} GThreadPriority;
</pre>
<p>
Определяет приоритет потока. 
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Не гарантируется что потоки с разными приоритетами будут вести себя соответственно. 
В некоторых системах (например Linux) нет приоритетов потоков. 
В других системах (например Solaris) существует разное планирование для разных приоритетов. 
В основном пытайтесь избегать зависимости от приоритетов.
</p>
</div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><a name="G-THREAD-PRIORITY-LOW:CAPS"></a><code class="literal">G_THREAD_PRIORITY_LOW</code></span></td>
<td>приоритет ниже нормального
</td>
</tr>
<tr>
<td><span class="term"><a name="G-THREAD-PRIORITY-NORMAL:CAPS"></a><code class="literal">G_THREAD_PRIORITY_NORMAL</code></span></td>
<td>приоритет по умолчанию
</td>
</tr>
<tr>
<td><span class="term"><a name="G-THREAD-PRIORITY-HIGH:CAPS"></a><code class="literal">G_THREAD_PRIORITY_HIGH</code></span></td>
<td>приоритет выше нормального
</td>
</tr>
<tr>
<td><span class="term"><a name="G-THREAD-PRIORITY-URGENT:CAPS"></a><code class="literal">G_THREAD_PRIORITY_URGENT</code></span></td>
<td>наивысший приоритет
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2587416"></a><h3>
<a name="GThread"></a>GThread</h3>
<a class="indexterm" name="id2587428"></a><pre class="programlisting">typedef struct {
} GThread;
</pre>
<p>
<a href="glib-Threads.html#GThread"><span class="type">GThread</span></a> структура представляет выполняемый поток. Она имеет три общих элемента доступных только для чтения, но основных в структуре 
больше, поэтому вы не должны копировать эту структуру.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Ресурсы для объединяемого потока реализуются не полностью пока для этого потока вызвана
<a href="glib-Threads.html#g-thread-join"><code class="function">g_thread_join()</code></a>.
</p>
</div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2587472"></a><h3>
<a name="g-thread-create"></a>g_thread_create ()</h3>
<a class="indexterm" name="id2587485"></a><pre class="programlisting"><a href="glib-Threads.html#GThread">GThread</a>*    g_thread_create                 (<a href="glib-Threads.html#GThreadFunc">GThreadFunc</a> func,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> data,
                                             <a href="glib-Basic-Types.html#gboolean">gboolean</a> joinable,
                                             <a href="glib-Error-Reporting.html#GError">GError</a> **error);</pre>
<p>
Эта функция создаёт новый поток с приоритетом по умолчанию.
</p>
<p>
Если <em class="parameter"><code>joinable</code></em> равен <a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>, вы можете подождать завершения потоков вызывающих 
<a href="glib-Threads.html#g-thread-join"><code class="function">g_thread_join()</code></a>. Иначе поток просто исчезнет когда она завершиться. 
</p>
<p>
Новый поток выполняет функцию <em class="parameter"><code>func</code></em> с параметром
<em class="parameter"><code>data</code></em>. Если поток был создан успешно, он возвращается.
</p>
<p>
<em class="parameter"><code>error</code></em> может быть <a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a> для игнорирования ошибок, или не-<a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a> для сообщения об ошибках. Ошибка устанавливается только если функция возвращает <a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>func</code></em>&#160;:</span></td>
<td>функция выполняемая в новом потоке.
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>data</code></em>&#160;:</span></td>
<td>аргумент поставляемый новому потоку.
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>joinable</code></em>&#160;:</span></td>
<td>должен ли поток быть объединяемым?
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>error</code></em>&#160;:</span></td>
<td>размещение для возвращаемой ошибки.
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>новый <a href="glib-Threads.html#GThread"><span class="type">GThread</span></a> при успешном выполнении.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2587707"></a><h3>
<a name="g-thread-create-full"></a>g_thread_create_full ()</h3>
<a class="indexterm" name="id2587721"></a><pre class="programlisting"><a href="glib-Threads.html#GThread">GThread</a>*    g_thread_create_full            (<a href="glib-Threads.html#GThreadFunc">GThreadFunc</a> func,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> data,
                                             <a href="glib-Basic-Types.html#gulong">gulong</a> stack_size,
                                             <a href="glib-Basic-Types.html#gboolean">gboolean</a> joinable,
                                             <a href="glib-Basic-Types.html#gboolean">gboolean</a> bound,
                                             <a href="glib-Threads.html#GThreadPriority">GThreadPriority</a> priority,
                                             <a href="glib-Error-Reporting.html#GError">GError</a> **error);</pre>
<p>
Эта функция создаёт поток с приоритетом <em class="parameter"><code>priority</code></em>. 
Если реализация потока поддерживает это, поток получает размер стека 
<em class="parameter"><code>stack_size</code></em> или значение по умолчанию для текущей платформы, 
если <em class="parameter"><code>stack_size</code></em> это 0.
</p>
<p>
Если <em class="parameter"><code>joinable</code></em> равно <a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>, вы можете подождать завершения вызова 
<a href="glib-Threads.html#g-thread-join"><code class="function">g_thread_join()</code></a> для потока. 
Иначе поток просто исчезнет при завершении. Если <em class="parameter"><code>bound</code></em> равен <a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>, этот поток 
будет планироваться в системной области, иначе реализация это свободно выполняемое планирование в 
пределах процесса. Первый вариант более требователен к ресурсам, но в общем быстрее. 
В некоторых системах (например Linux) все потоки связаны.
</p>
<p>
Новый поток выполняет функцию <em class="parameter"><code>func</code></em> с аргументом
<em class="parameter"><code>data</code></em>. Если поток был успешно создан, он возвращается.
</p>
<p>
<em class="parameter"><code>error</code></em> может быть <a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a> для игнорирования ошибок, или не-<a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a> для сообщения об ошибках. Ошибка устанавливается, только если функция вернула <a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a>.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Не гарантируется что потоки с разными приоритетами будут вести себя соответственно. 
В некоторых системах (например Linux) нет приоритетов потоков. 
В других системах (например Solaris) существует разное планирование для разных приоритетов. 
В основном пытайтесь избегать зависимости от приоритетов.
Используйте <a href="glib-Threads.html#G-THREAD-PRIORITY-NORMAL:CAPS"><code class="literal">G_THREAD_PRIORITY_NORMAL</code></a> здесь как значение по умолчанию.
</p>
</div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Используйте <a href="glib-Threads.html#g-thread-create-full"><code class="function">g_thread_create_full()</code></a> только если вы действительно не можете использовать 
<a href="glib-Threads.html#g-thread-create"><code class="function">g_thread_create()</code></a> вместо неё. 
<a href="glib-Threads.html#g-thread-create"><code class="function">g_thread_create()</code></a> 
не применяет <em class="parameter"><code>stack_size</code></em>, <em class="parameter"><code>bound</code></em>, и <em class="parameter"><code>priority</code></em> как аргументы, поскольку они должны использоваться только если это явно не избежно.
</p>
</div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>func</code></em>&#160;:</span></td>
<td>функция для выполнения в новом потоке.
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>data</code></em>&#160;:</span></td>
<td>аргумент поставляемый в новый поток.
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>stack_size</code></em>&#160;:</span></td>
<td>размер стека для нового потока.
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>joinable</code></em>&#160;:</span></td>
<td>должен ли этот поток быть объединяемым?
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>bound</code></em>&#160;:</span></td>
<td>должен ли этот поток привязываться к системе потоков?
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>priority</code></em>&#160;:</span></td>
<td>приоритет потока.
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>error</code></em>&#160;:</span></td>
<td>расположение для возвращаемой ошибки.
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>новый <a href="glib-Threads.html#GThread"><span class="type">GThread</span></a> при удачном выполнении.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2588132"></a><h3>
<a name="g-thread-self"></a>g_thread_self ()</h3>
<a class="indexterm" name="id2588145"></a><pre class="programlisting"><a href="glib-Threads.html#GThread">GThread</a>*    g_thread_self                   (void);</pre>
<p>
Эта функция возвращает <a href="glib-Threads.html#GThread"><span class="type">GThread</span></a> соответствующий вызываемому потоку.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>текущий поток.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2588190"></a><h3>
<a name="g-thread-join"></a>g_thread_join ()</h3>
<a class="indexterm" name="id2588203"></a><pre class="programlisting"><a href="glib-Basic-Types.html#gpointer">gpointer</a>    g_thread_join                   (<a href="glib-Threads.html#GThread">GThread</a> *thread);</pre>
<p>
Ждёт завершения <em class="parameter"><code>thread</code></em>, то есть функции <em class="parameter"><code>func</code></em>, полученной в <a href="glib-Threads.html#g-thread-create"><code class="function">g_thread_create()</code></a>, возврат или <a href="glib-Threads.html#g-thread-exit"><code class="function">g_thread_exit()</code></a> вызванный <em class="parameter"><code>thread</code></em>. 
Все ресурсы <em class="parameter"><code>thread</code></em> включая структуру <a href="glib-Threads.html#GThread"><span class="type">GThread</span></a> освобождаются. 
<em class="parameter"><code>thread</code></em> должен быть создан с <em class="parameter"><code>joinable</code></em>=<a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>
 в <a href="glib-Threads.html#g-thread-create"><code class="function">g_thread_create()</code></a>. Значение возвращаемое <em class="parameter"><code>func</code></em> или полученное в
<a href="glib-Threads.html#g-thread-exit"><code class="function">g_thread_exit()</code></a><em class="parameter"><code>thread</code></em> возвращается этой функцией.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>thread</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GThread"><span class="type">GThread</span></a> из которого ожидается результат.
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>возвращаемое потоком значение.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2588380"></a><h3>
<a name="g-thread-set-priority"></a>g_thread_set_priority ()</h3>
<a class="indexterm" name="id2588393"></a><pre class="programlisting">void        g_thread_set_priority           (<a href="glib-Threads.html#GThread">GThread</a> *thread,
                                             <a href="glib-Threads.html#GThreadPriority">GThreadPriority</a> priority);</pre>
<p>
Изменяет приоритет <em class="parameter"><code>thread</code></em> в значение <em class="parameter"><code>priority</code></em>.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Не гарантируется что потоки с разными приоритетами будут вести себя соответственно. 
В некоторых системах (например Linux) нет приоритетов потоков. 
В других системах (например Solaris) существует разное планирование для разных приоритетов. 
В основном пытайтесь избегать зависимости от приоритетов.
</p>
</div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>thread</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GThread"><span class="type">GThread</span></a>.
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>priority</code></em>&#160;:</span></td>
<td>новый приоритет для <em class="parameter"><code>thread</code></em>.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2588499"></a><h3>
<a name="g-thread-yield"></a>g_thread_yield ()</h3>
<a class="indexterm" name="id2588511"></a><pre class="programlisting">void        g_thread_yield                  ();</pre>
<p>
Позволяет запланировать другой поток. 
</p>
<p>
Эта функция часто используется как метод для создания занятого ожидания менее вредным. 
Но в большинстве случаев есть лучше методы для этого. Поэтому в основном вы не должны использовать 
эту функцию.
</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2588540"></a><h3>
<a name="g-thread-exit"></a>g_thread_exit ()</h3>
<a class="indexterm" name="id2588553"></a><pre class="programlisting">void        g_thread_exit                   (<a href="glib-Basic-Types.html#gpointer">gpointer</a> retval);</pre>
<p>
Выход из текущего потока. Если другой поток ожидает завершение этого потока используя функцию 
<a href="glib-Threads.html#g-thread-join"><code class="function">g_thread_join()</code></a> и 
текущий поток является совмещённым, то ожидающий поток будет разбужен и получит 
<em class="parameter"><code>retval</code></em> как возвращаемое значение
<a href="glib-Threads.html#g-thread-join"><code class="function">g_thread_join()</code></a>. 
Если текущий поток не совмещён, <em class="parameter"><code>retval</code></em> игнорируется. 
Вызов
</p>
<p>
</p>
<div class="informalexample"><pre class="programlisting">
g_thread_exit (retval);
</pre></div>
<p>
</p>
<p>
эквивалентен вызову 
</p>
<p>
</p>
<div class="informalexample"><pre class="programlisting">
return retval;
</pre></div>
<p>
</p>
<p>
в функции <em class="parameter"><code>func</code></em>, полученной в <a href="glib-Threads.html#g-thread-create"><code class="function">g_thread_create()</code></a>.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Никогда не вызывайте <a href="glib-Threads.html#g-thread-exit"><code class="function">g_thread_exit()</code></a> внутри потока <a href="glib-Thread-Pools.html#GThreadPool"><span class="type">GThreadPool</span></a>, так как это запутает расчеты и приведёт к нежелательным последствиям.
</p>
</div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>retval</code></em>&#160;:</span></td>
<td>значение возвращаемое этим потоком.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2588714"></a><h3>
<a name="g-thread-foreach"></a>g_thread_foreach ()</h3>
<a class="indexterm" name="id2588729"></a><pre class="programlisting">void        g_thread_foreach                (<a href="glib-Doubly-Linked-Lists.html#GFunc">GFunc</a> thread_func,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> user_data);</pre>
<p>
Вызывает <em class="parameter"><code>thread_func</code></em> на всех существующих структурах <a href="glib-Threads.html#GThread"><span class="type">GThread</span></a>. Помните, что потоки могут 
принять решение о выходе в то время как <em class="parameter"><code>thread_func</code></em> 
выполняется, поэтому без близкого знания продолжительности жизни внешних потоков,
<em class="parameter"><code>thread_func</code></em> не имеет доступа к указателю GThread* 
помещаемому в первый аргумент. Однако, <em class="parameter"><code>thread_func</code></em> не будет вызвана для потоков выход из которых уже совершён.
</p>
<p>
Из-за проверок жизненного цикла потока, эта функция имеет сложности при выполнении
которые взводятся в степень количества существующих потоков.</p>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>thread_func</code></em>&#160;:</span></td>
<td> функция вызываемая для всех структур GThread
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>user_data</code></em>&#160;:</span></td>
<td> второй аргумент для <em class="parameter"><code>thread_func</code></em>
</td>
</tr>
</tbody>
</table></div>
<p>Начиная с версии 2.10
</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2588853"></a><h3>
<a name="GMutex"></a>GMutex</h3>
<a class="indexterm" name="id2588866"></a><pre class="programlisting">typedef struct _GMutex GMutex;</pre>
<p>
Структура <a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a> - закрытая структура данных представляющая взаимоисключения (mutex - mutual exclusion). Она может использоваться для защиты данных от совместного доступа. 
Возьмём например следующую функцию:

</p>
<div class="example">
<a name="id2588891"></a><p class="title"><b>Пример&#160;3.&#160;Функция которая не будет работать в потоковом окружении</b></p>
<pre class="programlisting">
  int give_me_next_number ()
  {
    static int current_number = 0;

    /* теперь выполняем очень cложное вычисление для расчёта нового числа,
       это может быть например генератор случайных чисел */
    current_number = calc_next_number (current_number); 
    return current_number;
  }
</pre>
</div>
<p>
</p>
<p>
Просто заметить что это не будет работать в многопоточных приложениях. 
Переменная current_number должна быть защищена от совместного доступа. 
Первая наивная реализация могла бы быть такой:
</p>
<p>
</p>
<div class="example">
<a name="id2588922"></a><p class="title"><b>Пример&#160;4.&#160;Не правильный способ создания потоко-безопасной функции</b></p>
<pre class="programlisting">
  int give_me_next_number ()
  {
    static int current_number = 0;
    int ret_val;
    static GMutex * mutex = NULL;

    if (!mutex)
      mutex = g_mutex_new ();
    g_mutex_lock (mutex);
    ret_val = current_number = calc_next_number (current_number); 
    g_mutex_unlock (mutex);
    return ret_val;
  }
</pre>
</div>
<p>
</p>
<p>
Похоже что это должно работать, но есть условие гонки пока создаётся взаимоисключение
и этот код не может надежно работать. Пожалуйста не используйте эту конструкцию в собственных
программах! Вот одно работающее решение:
</p>
<p>
</p>
<div class="example">
<a name="id2588955"></a><p class="title"><b>Пример&#160;5.&#160;A correct thread-safe function</b></p>
<pre class="programlisting">
  static GMutex *give_me_next_number_mutex = NULL;

  /* эта функция должна быть вызвана перед любым вызовом give_me_next_number ()
     она должна вызываться только один раз. */
  void init_give_me_next_number () 
  {
    g_assert (give_me_next_number_mutex == NULL);
    give_me_next_number_mutex = g_mutex_new ();
  }

  int give_me_next_number ()
  {
    static int current_number = 0;
    int ret_val;

    g_mutex_lock (give_me_next_number_mutex);
    ret_val = current_number = calc_next_number (current_number); 
    g_mutex_unlock (give_me_next_number_mutex);
    return ret_val;
  }
</pre>
</div>
<p>
</p>
<p>
<a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a> обеспечивает более простой и безопасный способ выполнения этого.
</p>
<p>
Если вы хотите использовать взаимоисключения и ваш код должен также работать не вызывая сначала
<a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a>, 
то вы не можете использовать <a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a>, так как 
<a href="glib-Threads.html#g-mutex-new"><code class="function">g_mutex_new()</code></a> требует инициализации системы потоков. 
Вместо этого используйте <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>.
</p>
<p>
Доступ к <a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a> должен производиться только с помощью функций описанных ниже.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Все <code class="function">g_mutex_*</code> функции фактически являются макрокомандами. 
Кроме взятия адреса, вы можете однако использовать их как будто они являются функциями.
</p>
</div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2589071"></a><h3>
<a name="g-mutex-new"></a>g_mutex_new ()</h3>
<a class="indexterm" name="id2589083"></a><pre class="programlisting"><a href="glib-Threads.html#GMutex">GMutex</a>*     g_mutex_new                     ();</pre>
<p>
Создаёт новую структуру <a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a>. 
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Эта функция прерывается если не вызвана <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a>.
</p>
</div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>новая структура <a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a>.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2589153"></a><h3>
<a name="g-mutex-lock"></a>g_mutex_lock ()</h3>
<a class="indexterm" name="id2589166"></a><pre class="programlisting">void        g_mutex_lock                    (<a href="glib-Threads.html#GMutex">GMutex</a> *mutex);</pre>
<p>
Блокирует <em class="parameter"><code>mutex</code></em>. Если <em class="parameter"><code>mutex</code></em> уже блокирован другим потоком, то текущий поток блокируется пока <em class="parameter"><code>mutex</code></em> не будет разблокирован.
</p>
<p>
Эта функция может использоваться даже если <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> не была вызвана, в этом случае она не делает ничего.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
<a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a> не гарантирует не рекурсию не её отсутсвие, то есть поток может зависнуть вызывая <a href="glib-Threads.html#g-mutex-lock"><code class="function">g_mutex_lock()</code></a>, если она уже заблокировала <em class="parameter"><code>mutex</code></em>. 
Используйте <a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a>, если вам нужны рекурсивные взаимоисключения.
</p>
</div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a>.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2589297"></a><h3>
<a name="g-mutex-trylock"></a>g_mutex_trylock ()</h3>
<a class="indexterm" name="id2589310"></a><pre class="programlisting"><a href="glib-Basic-Types.html#gboolean">gboolean</a>    g_mutex_trylock                 (<a href="glib-Threads.html#GMutex">GMutex</a> *mutex);</pre>
<p>
Пытается блокировать <em class="parameter"><code>mutex</code></em>. Если <em class="parameter"><code>mutex</code></em> уже заблокирован другим потоком, она немедленно возвращает <a href="glib-Standard-Macros.html#FALSE:CAPS"><code class="literal">FALSE</code></a>. Иначе блокируется <em class="parameter"><code>mutex</code></em>
и возвращается <a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>.
</p>
<p>
Эта функция может использоваться даже если <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> не была вызвана, 
в этом случае она немедленно вернёт <a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
<a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a> не гарантирует рекурсию не её отсутсвие,
то есть возвращаемое значение <a href="glib-Threads.html#g-mutex-trylock"><code class="function">g_mutex_trylock()</code></a> может быть и <a href="glib-Standard-Macros.html#FALSE:CAPS"><code class="literal">FALSE</code></a> и
<a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>, если текущий поток уже заблокировал <em class="parameter"><code>mutex</code></em>. 
Используйте <a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a>, если вам нужны рекурсивные взаимоисключения.
</p>
</div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a>.
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>
<a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>, если <em class="parameter"><code>mutex</code></em> может быть заблокирован.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2589517"></a><h3>
<a name="g-mutex-unlock"></a>g_mutex_unlock ()</h3>
<a class="indexterm" name="id2589530"></a><pre class="programlisting">void        g_mutex_unlock                  (<a href="glib-Threads.html#GMutex">GMutex</a> *mutex);</pre>
<p>
Разблокирует <em class="parameter"><code>mutex</code></em>. Если другой поток блокирован в <a href="glib-Threads.html#g-mutex-lock"><code class="function">g_mutex_lock()</code></a> вызовом для <em class="parameter"><code>mutex</code></em>, то он будет разбужен и сможет заблокировать <em class="parameter"><code>mutex</code></em> самостоятельно.
</p>
<p>
Эта функция может использоваться даже если <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> не была вызвана, в этом случае она ничего не делает.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a>.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2589629"></a><h3>
<a name="g-mutex-free"></a>g_mutex_free ()</h3>
<a class="indexterm" name="id2589642"></a><pre class="programlisting">void        g_mutex_free                    (<a href="glib-Threads.html#GMutex">GMutex</a> *mutex);</pre>
<p>
Уничтожает <em class="parameter"><code>mutex</code></em>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a>.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2589702"></a><h3>
<a name="GStaticMutex"></a>GStaticMutex</h3>
<a class="indexterm" name="id2589715"></a><pre class="programlisting">typedef struct _GStaticMutex GStaticMutex;</pre>
<p>
<a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a> работает также как <a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a>, но имеет одно существенное преимущество. Она не должна создаваться во время выполнения как <a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a>,
а может быть определена во время компиляции. Вот более короткий и более безопасный пример нашей 
функции <code class="function"><code class="function">give_me_next_number()</code></code>:
</p>
<p>
</p>
<div class="example">
<a name="id2589776"></a><p class="title"><b>Пример&#160;6.&#160;Использование <span class="structname">GStaticMutex</span> для упрощения потокобезопасного программирования</b></p>
<pre class="programlisting">
  int give_me_next_number ()
  {
    static int current_number = 0;
    int ret_val;
    static GStaticMutex mutex = G_STATIC_MUTEX_INIT;

    g_static_mutex_lock (&amp;mutex);
    ret_val = current_number = calc_next_number (current_number); 
    g_static_mutex_unlock (&amp;mutex);
    return ret_val;
  }
</pre>
</div>
<p>
</p>
<p>
Иногда вам может понадобиться создавать динамические взаимоисключения. Если вы не хотите 
предварительно вызывать <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a>, потому что ваш код должен также использоваться в не потоковых программах, 
вы не сможете использовать <a href="glib-Threads.html#g-mutex-new"><code class="function">g_mutex_new()</code></a> а также <a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a>, 
так как требуется предварительный вызов <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a>. В этом случае вы также можете использовать <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>. 
Она должна быть инициализирована перед использованием с помощью <a href="glib-Threads.html#g-static-mutex-init"><code class="function">g_static_mutex_init()</code></a> 
и освобождена с помощью <a href="glib-Threads.html#g-static-mutex-free"><code class="function">g_static_mutex_free()</code></a> когда нет больше никаких освобождаемых распределённых ресурсов.
</p>
<p>
Даже при том, что <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a> не непрозрачная структура, она должна использоваться только следующими функциями, так как она определяется по разному на разных платформах.
</p>
<p>
Все функции <code class="function">g_static_mutex_*</code> могут использоваться даже если не 
была вызвана <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a>.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Все функции <code class="function">g_static_mutex_*</code> фактически являются макросами. 
Однако, кроме взятия адреса, вы можете использовать их как функции.
</p>
</div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2589930"></a><h3>
<a name="G-STATIC-MUTEX-INIT:CAPS"></a>G_STATIC_MUTEX_INIT</h3>
<a class="indexterm" name="id2589944"></a><pre class="programlisting">#define G_STATIC_MUTEX_INIT
</pre>
<p>
С помощью этого макроса должна инициализироваться <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>, перед использованием. 
Этот макрос может использоваться для инициализации переменной, но он не может присваиваться 
переменной. В этом случае вы должны использовать
<a href="glib-Threads.html#g-static-mutex-init"><code class="function">g_static_mutex_init()</code></a>.
</p>
<p>
</p>
<div class="informalexample"><pre class="programlisting">
GStaticMutex my_mutex = G_STATIC_MUTEX_INIT;
</pre></div>
<p>
</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2589993"></a><h3>
<a name="g-static-mutex-init"></a>g_static_mutex_init ()</h3>
<a class="indexterm" name="id2590007"></a><pre class="programlisting">void        g_static_mutex_init             (<a href="glib-Threads.html#GStaticMutex">GStaticMutex</a> *mutex);</pre>
<p>
Инициализирует <em class="parameter"><code>mutex</code></em>. Альтернативно его можно инициализировать с помощью
<a href="glib-Threads.html#G-STATIC-MUTEX-INIT:CAPS"><span class="type">G_STATIC_MUTEX_INIT</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a> для инициализации.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2590077"></a><h3>
<a name="g-static-mutex-lock"></a>g_static_mutex_lock ()</h3>
<a class="indexterm" name="id2590090"></a><pre class="programlisting">void        g_static_mutex_lock             (<a href="glib-Threads.html#GStaticMutex">GStaticMutex</a> *mutex);</pre>
<p>
Работает как <a href="glib-Threads.html#g-mutex-lock"><code class="function">g_mutex_lock()</code></a>, но для <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2590164"></a><h3>
<a name="g-static-mutex-trylock"></a>g_static_mutex_trylock ()</h3>
<a class="indexterm" name="id2590176"></a><pre class="programlisting"><a href="glib-Basic-Types.html#gboolean">gboolean</a>    g_static_mutex_trylock          (<a href="glib-Threads.html#GStaticMutex">GStaticMutex</a> *mutex);</pre>
<p>
Работает как <a href="glib-Threads.html#g-mutex-trylock"><code class="function">g_mutex_trylock()</code></a>, но для <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>.
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>
<a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>, если <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a> может быть заблокирован.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2590278"></a><h3>
<a name="g-static-mutex-unlock"></a>g_static_mutex_unlock ()</h3>
<a class="indexterm" name="id2590292"></a><pre class="programlisting">void        g_static_mutex_unlock           (<a href="glib-Threads.html#GStaticMutex">GStaticMutex</a> *mutex);</pre>
<p>
Работает как <a href="glib-Threads.html#g-mutex-unlock"><code class="function">g_mutex_unlock()</code></a>, но для <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2590366"></a><h3>
<a name="g-static-mutex-get-mutex"></a>g_static_mutex_get_mutex ()</h3>
<a class="indexterm" name="id2590379"></a><pre class="programlisting"><a href="glib-Threads.html#GMutex">GMutex</a>*     g_static_mutex_get_mutex        (<a href="glib-Threads.html#GStaticMutex">GStaticMutex</a> *mutex);</pre>
<p>
Для некоторых операций (как <a href="glib-Threads.html#g-cond-wait"><code class="function">g_cond_wait()</code></a>) вы должны использовать <a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a>
вместо <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>. 
Эта функция соответственно возвращает <a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a> для <em class="parameter"><code>mutex</code></em>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>.
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td><a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a> соответствующий <em class="parameter"><code>mutex</code></em>.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2590500"></a><h3>
<a name="g-static-mutex-free"></a>g_static_mutex_free ()</h3>
<a class="indexterm" name="id2590513"></a><pre class="programlisting">void        g_static_mutex_free             (<a href="glib-Threads.html#GStaticMutex">GStaticMutex</a> *mutex);</pre>
<p>
Освобождает все ресурсы распределённые для <em class="parameter"><code>mutex</code></em>. 
</p>
<p>
Вы не должны вызывать эту функцию для <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a> с неограниченным жизненным циклом, 
то есть для объектов объявленных как 'static', но если <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a> является членом структуры и структура освобождается,
вы должны также освободить <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a> для освобождения.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2590606"></a><h3>
<a name="G-LOCK-DEFINE:CAPS"></a>G_LOCK_DEFINE()</h3>
<a class="indexterm" name="id2590618"></a><pre class="programlisting">#define     G_LOCK_DEFINE(name)</pre>
<p>
Макрос <code class="literal">G_LOCK_</code>* обеспечивает удобный интерфейс для 
<a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>
с преимуществом распространения для программ скомпилированных без поддержки потоков GLib, сохраняя 
код и память. <a href="glib-Threads.html#G-LOCK-DEFINE:CAPS"><span class="type">G_LOCK_DEFINE</span></a> определяет блокировку. Он может появляться там же где могут появляться переменные в программах, 
то есть в первом блоке функции или вне функций. Параметр <em class="parameter"><code>name</code></em> будет изменён для получения имени <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>. Это значит что вы можете использовать имена существующих переменных как 
параметр - например имя переменной вы можете защитить с помощью блокировки. Рассмотрим наш пример
<code class="function"><code class="function">give_me_next_number()</code></code> с использованием <code class="literal">G_LOCK_</code>* macros:
</p>
<p>
</p>
<div class="example">
<a name="id2590712"></a><p class="title"><b>Пример&#160;7.&#160;Использование удобного макроса <code class="literal">G_LOCK_</code>*</b></p>
<pre class="programlisting">
G_LOCK_DEFINE (current_number);

int give_me_next_number ()
  {
    static int current_number = 0;
    int ret_val;

    G_LOCK (current_number);
    ret_val = current_number = calc_next_number (current_number); 
    G_UNLOCK (current_number);
    return ret_val;
  }
</pre>
</div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>name</code></em>&#160;:</span></td>
<td>имя блокировки.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2590762"></a><h3>
<a name="G-LOCK-DEFINE-STATIC:CAPS"></a>G_LOCK_DEFINE_STATIC()</h3>
<a class="indexterm" name="id2590775"></a><pre class="programlisting">#define     G_LOCK_DEFINE_STATIC(name)</pre>
<p>
Работает также как <a href="glib-Threads.html#G-LOCK-DEFINE:CAPS"><span class="type">G_LOCK_DEFINE</span></a>, но создаёт статический объект.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>name</code></em>&#160;:</span></td>
<td>имя блокировки.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2590818"></a><h3>
<a name="G-LOCK-EXTERN:CAPS"></a>G_LOCK_EXTERN()</h3>
<a class="indexterm" name="id2590831"></a><pre class="programlisting">#define     G_LOCK_EXTERN(name)</pre>
<p>
Объявляет блокировку, которая определена с помощью <a href="glib-Threads.html#G-LOCK-DEFINE:CAPS"><span class="type">G_LOCK_DEFINE</span></a> в другом модуле.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>name</code></em>&#160;:</span></td>
<td>имя блокировки.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2590874"></a><h3>
<a name="G-LOCK:CAPS"></a>G_LOCK()</h3>
<a class="indexterm" name="id2590886"></a><pre class="programlisting">#define     G_LOCK(name)</pre>
<p>
Работает также как <a href="glib-Threads.html#g-mutex-lock"><code class="function">g_mutex_lock()</code></a>, но для блокировки определённой с помощью<a href="glib-Threads.html#G-LOCK-DEFINE:CAPS"><span class="type">G_LOCK_DEFINE</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>name</code></em>&#160;:</span></td>
<td>имя блокировки.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2590940"></a><h3>
<a name="G-TRYLOCK:CAPS"></a>G_TRYLOCK()</h3>
<a class="indexterm" name="id2590952"></a><pre class="programlisting">#define     G_TRYLOCK(name)</pre>
<p>
Работает также как <a href="glib-Threads.html#g-mutex-trylock"><code class="function">g_mutex_trylock()</code></a>, но для блокировки определённой с помощью <a href="glib-Threads.html#G-LOCK-DEFINE:CAPS"><span class="type">G_LOCK_DEFINE</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>name</code></em>&#160;:</span></td>
<td>имя блокировки.
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>
<a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>, если блокировка может быть блокирована.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2591025"></a><h3>
<a name="G-UNLOCK:CAPS"></a>G_UNLOCK()</h3>
<a class="indexterm" name="id2591038"></a><pre class="programlisting">#define     G_UNLOCK(name)</pre>
<p>
Работает также как <a href="glib-Threads.html#g-mutex-unlock"><code class="function">g_mutex_unlock()</code></a>, но для блокировки определённой с помощью <a href="glib-Threads.html#G-LOCK-DEFINE:CAPS"><span class="type">G_LOCK_DEFINE</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>name</code></em>&#160;:</span></td>
<td>имя блокировки.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2591090"></a><h3>
<a name="GStaticRecMutex"></a>GStaticRecMutex</h3>
<a class="indexterm" name="id2591103"></a><pre class="programlisting">typedef struct {
} GStaticRecMutex;
</pre>
<p>
<a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a> работает также как <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>, но он может быть блокирован множество раз одним потоком. 
Если вы ввели его n раз, вы должны разблокировать его n раз позволяя другим потокам блокировать его.
 Исключением является функция <a href="glib-Threads.html#g-static-rec-mutex-unlock-full"><code class="function">g_static_rec_mutex_unlock_full()</code></a>: она позволяет вам разблокировать <a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a> на всю глубину полностью, (то есть на то количество раз на которое был заблокирован этот объект mutex). 
Глубина может позже использоваться для восстановления состояния <a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a> с помощью вызова
<a href="glib-Threads.html#g-static-rec-mutex-lock-full"><code class="function">g_static_rec_mutex_lock_full()</code></a>.
</p>
<p>
Даже при том, что <a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a> не является закрытой, она должна использоваться только следующими функциями.
</p>
<p>
Все функции <code class="function">g_static_rec_mutex_*</code> могут использоваться даже если не 
была вызвана <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a>.
</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2591214"></a><h3>
<a name="G-STATIC-REC-MUTEX-INIT:CAPS"></a>G_STATIC_REC_MUTEX_INIT</h3>
<a class="indexterm" name="id2591229"></a><pre class="programlisting">#define G_STATIC_REC_MUTEX_INIT { G_STATIC_MUTEX_INIT }
</pre>
<p>
<a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a> должна быть инициализирована с помощью макроса перед использованием. 
Этот макрос может использоваться для инициализации переменных, но он не должен назначаться переменным. Для этого случая используется <a href="glib-Threads.html#g-static-rec-mutex-init"><code class="function">g_static_rec_mutex_init()</code></a>.
</p>
<p>
</p>
<div class="informalexample"><pre class="programlisting">
GStaticRecMutex my_mutex = G_STATIC_REC_MUTEX_INIT;
</pre></div>
<p>
</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2591280"></a><h3>
<a name="g-static-rec-mutex-init"></a>g_static_rec_mutex_init ()</h3>
<a class="indexterm" name="id2591293"></a><pre class="programlisting">void        g_static_rec_mutex_init         (<a href="glib-Threads.html#GStaticRecMutex">GStaticRecMutex</a> *mutex);</pre>
<p>
<a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a> должна инициализироваться с помощью этой функции перед использованием. Альтернативно вы можете инициализировать её с помощью <a href="glib-Threads.html#G-STATIC-REC-MUTEX-INIT:CAPS"><span class="type">G_STATIC_REC_MUTEX_INIT</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a> для инициализации.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2591367"></a><h3>
<a name="g-static-rec-mutex-lock"></a>g_static_rec_mutex_lock ()</h3>
<a class="indexterm" name="id2591380"></a><pre class="programlisting">void        g_static_rec_mutex_lock         (<a href="glib-Threads.html#GStaticRecMutex">GStaticRecMutex</a> *mutex);</pre>
<p>
Блокирует <em class="parameter"><code>mutex</code></em>. Если <em class="parameter"><code>mutex</code></em> уже заблокирован другим потоком, текущий поток будет заблокирован пока <em class="parameter"><code>mutex</code></em> не разблокируется. Если <em class="parameter"><code>mutex</code></em> уже заблокирован вызываемым потоком, эта функция увеличит глубину блокировки <em class="parameter"><code>mutex</code></em> и немедленно возвратит.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a> для блокирования.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2591468"></a><h3>
<a name="g-static-rec-mutex-trylock"></a>g_static_rec_mutex_trylock ()</h3>
<a class="indexterm" name="id2591481"></a><pre class="programlisting"><a href="glib-Basic-Types.html#gboolean">gboolean</a>    g_static_rec_mutex_trylock      (<a href="glib-Threads.html#GStaticRecMutex">GStaticRecMutex</a> *mutex);</pre>
<p>
Пытается блокировать <em class="parameter"><code>mutex</code></em>. Если <em class="parameter"><code>mutex</code></em> уже заблокирован другим потоком,
она немедленно возвращает <a href="glib-Standard-Macros.html#FALSE:CAPS"><code class="literal">FALSE</code></a>. Иначе <em class="parameter"><code>mutex</code></em> блокируется и возвращается <a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>. Если <em class="parameter"><code>mutex</code></em> уже заблокирован вызываемым потоком, эта функция увеличивает глубину блокировки <em class="parameter"><code>mutex</code></em> и немедленно возвращает <a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a> для блокировки.
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>
<a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>, если <em class="parameter"><code>mutex</code></em> может быть заблокирован.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2591625"></a><h3>
<a name="g-static-rec-mutex-unlock"></a>g_static_rec_mutex_unlock ()</h3>
<a class="indexterm" name="id2591639"></a><pre class="programlisting">void        g_static_rec_mutex_unlock       (<a href="glib-Threads.html#GStaticRecMutex">GStaticRecMutex</a> *mutex);</pre>
<p>
Разблокирует <em class="parameter"><code>mutex</code></em>. Другой поток может быть допущен к блокировки <em class="parameter"><code>mutex</code></em> только когда он будет разблокирован такое же количество раз сколько раз был заблокирован перед этим. 
Если <em class="parameter"><code>mutex</code></em> полностью разблокирован а другой поток блокирован в <a href="glib-Threads.html#g-static-rec-mutex-lock"><code class="function">g_static_rec_mutex_lock()</code></a> вызове для <em class="parameter"><code>mutex</code></em>, он будет разбужен и сможет заблокировать <em class="parameter"><code>mutex</code></em> самостоятельно.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a> для разблокирования.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2591738"></a><h3>
<a name="g-static-rec-mutex-lock-full"></a>g_static_rec_mutex_lock_full ()</h3>
<a class="indexterm" name="id2591751"></a><pre class="programlisting">void        g_static_rec_mutex_lock_full    (<a href="glib-Threads.html#GStaticRecMutex">GStaticRecMutex</a> *mutex,
                                             <a href="glib-Basic-Types.html#guint">guint</a> depth);</pre>
<p>
Работает также как вызов <a href="glib-Threads.html#g-static-rec-mutex-lock"><code class="function">g_static_rec_mutex_lock()</code></a> для <em class="parameter"><code>mutex</code></em> <em class="parameter"><code>depth</code></em> раз.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a> для разблокирования.
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>depth</code></em>&#160;:</span></td>
<td>количество разблокирований для полного разблокирования.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2591852"></a><h3>
<a name="g-static-rec-mutex-unlock-full"></a>g_static_rec_mutex_unlock_full ()</h3>
<a class="indexterm" name="id2591866"></a><pre class="programlisting"><a href="glib-Basic-Types.html#guint">guint</a>       g_static_rec_mutex_unlock_full  (<a href="glib-Threads.html#GStaticRecMutex">GStaticRecMutex</a> *mutex);</pre>
<p>
Полностью разблокирует <em class="parameter"><code>mutex</code></em>. Если другой поток блокирован в <a href="glib-Threads.html#g-static-rec-mutex-lock"><code class="function">g_static_rec_mutex_lock()</code></a> вызове для <em class="parameter"><code>mutex</code></em>, он будет разбужен и сможет заблокировать <em class="parameter"><code>mutex</code></em> самостоятельно. Эта функция возвращает количество раз которое <em class="parameter"><code>mutex</code></em> был заблокирован текущим потоком. 
Для восстановления состояния перед вызовом <a href="glib-Threads.html#g-static-rec-mutex-unlock-full"><code class="function">g_static_rec_mutex_unlock_full()</code></a> вы можете вызвать
<a href="glib-Threads.html#g-static-rec-mutex-lock-full"><code class="function">g_static_rec_mutex_lock_full()</code></a> с глубиной возвращаемой этой функцией.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a> для полного разблокирования.
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>количество раз которым <em class="parameter"><code>mutex</code></em> был заблокирован текущим процессом.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2592000"></a><h3>
<a name="g-static-rec-mutex-free"></a>g_static_rec_mutex_free ()</h3>
<a class="indexterm" name="id2592014"></a><pre class="programlisting">void        g_static_rec_mutex_free         (<a href="glib-Threads.html#GStaticRecMutex">GStaticRecMutex</a> *mutex);</pre>
<p>
Освобождает все ресурсы распределённые для <a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a>.
</p>
<p>
Вы не должны вызывать эту функцию для <a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a> с безграничным жизненным циклом, 
то есть для объектов объявленных как 'static', 
но если <a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a> является членом освобождаемой структуры, 
вы должны также освободить <a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticRecMutex"><span class="type">GStaticRecMutex</span></a> для освобождения.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2592109"></a><h3>
<a name="GStaticRWLock"></a>GStaticRWLock</h3>
<a class="indexterm" name="id2592121"></a><pre class="programlisting">typedef struct {
} GStaticRWLock;
</pre>
<p>
Структура <a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a> представляет блокировку чтения-записи. Блокировка чтения-записи может использоваться для защиты данных 
которые некоторые части кода только читают, в то время как другие также записывают. 
В таких ситуациях конечно лучше чтобы читать могли несколько процессов/потоков одновременно, а писать только один. Рассмотрим следующий пример:
</p>
<div class="example">
<a name="id2584600"></a><p class="title"><b>Пример&#160;8.&#160;Массив с функциями доступа</b></p>
<pre class="programlisting">
  GStaticRWLock rwlock = G_STATIC_RW_LOCK_INIT;

  GPtrArray *array;

  gpointer my_array_get (guint index)
  {
    gpointer retval = NULL;

    if (!array)
      return NULL;

    g_static_rw_lock_reader_lock (&amp;rwlock);

    if (index &lt; array-&gt;len)
      retval = g_ptr_array_index (array, index);

    g_static_rw_lock_reader_unlock (&amp;rwlock);

    return retval;
  }

  void my_array_set (guint index, gpointer data)
  {
    g_static_rw_lock_writer_lock (&amp;rwlock);

    if (!array)
      array = g_ptr_array_new ();

    if (index &gt;= array-&gt;len)
      g_ptr_array_set_size (array, index+1);

    g_ptr_array_index (array, index) = data; 

    g_static_rw_lock_writer_unlock (&amp;rwlock);
  }
</pre>
</div>
<p>
</p>
<p>
Этот пример демонстрирует массив доступ к которому позволен многим "читателям"
(<code class="function"><code class="function">my_array_get()</code></code> функция) одновременно, 
тогда как "писателям" (<code class="function"><code class="function">my_array_set()</code></code> функция) 
он доступен только одному за раз и только если нет "читателей" обращающихся к массиву в текущий 
момент. Это из-за потенциальной опасности изменения размера массива. При таком использовании функции полностью безопасны в много-поточности. 
</p>
<p>
В большинстве случаев, "писатель" должен иметь преимущество перед "читателями". Это значит, 
для этой реализации, как только "писатель" захочет блокировать данные никому из "читателей"
не позволено блокировать их, хотя "читателям" которые уже блокировали данные конечно позволено 
завершить свои операции. Как только последний "читатель" разблокировал данные, "писатель" блокирует их.
</p>
<p>
Даже при том, что структура <a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a> 
не является закрытой, доступ к ней должен осуществляться только с помощью функций описанных ниже.
</p>
<p>
Все функции <code class="function">g_static_rw_lock_*</code> могут использоваться даже если 
<a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> не была вызвана.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Блокировка чтение-запись имеет приоритет над взаимоисключениями (mutex). Например, обе
<a href="glib-Threads.html#g-static-rw-lock-reader-lock"><code class="function">g_static_rw_lock_reader_lock()</code></a> и <a href="glib-Threads.html#g-static-rw-lock-reader-unlock"><code class="function">g_static_rw_lock_reader_unlock()</code></a>
должны блокировать и разблокировать <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>, поэтому по крайней мере дважды блокируется и разблокируется 
<a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a> который в свою очередь блокирует и разблокирует <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>. Таким образом структуры данных которые доступны для множества "читателей" 
и которые сохраняют блокировку в течении длительного времени оправдывают <a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a>. Выше упомянутый пример вероятней всего 
намного лучше использовать с <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>.
</p>
</div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2592486"></a><h3>
<a name="G-STATIC-RW-LOCK-INIT:CAPS"></a>G_STATIC_RW_LOCK_INIT</h3>
<a class="indexterm" name="id2592500"></a><pre class="programlisting">#define G_STATIC_RW_LOCK_INIT { G_STATIC_MUTEX_INIT, NULL, NULL, 0, FALSE, 0, 0 }
</pre>
<p>
<a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a> должна быть инициализирована макросом перед использованием. Этот макрос может использоваться для инициализации переменных, но он не должен присваиваться переменным. В этом случае вы должны использовать
<a href="glib-Threads.html#g-static-rw-lock-init"><code class="function">g_static_rw_lock_init()</code></a>.
</p>
<p>
</p>
<div class="informalexample"><pre class="programlisting">
GStaticRWLock my_lock = G_STATIC_RW_LOCK_INIT;
</pre></div>
<p>
</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2592551"></a><h3>
<a name="g-static-rw-lock-init"></a>g_static_rw_lock_init ()</h3>
<a class="indexterm" name="id2592564"></a><pre class="programlisting">void        g_static_rw_lock_init           (<a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a> *lock);</pre>
<p>
<a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a> должна быть инициализирована с помощью этой функции перед использованием. Альтернативно вы можете инициализировать её с помощью <a href="glib-Threads.html#G-STATIC-RW-LOCK-INIT:CAPS"><span class="type">G_STATIC_RW_LOCK_INIT</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>lock</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a> для инициализации.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2592638"></a><h3>
<a name="g-static-rw-lock-reader-lock"></a>g_static_rw_lock_reader_lock ()</h3>
<a class="indexterm" name="id2592652"></a><pre class="programlisting">void        g_static_rw_lock_reader_lock    (<a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a> *lock);</pre>
<p>
Блокирует <em class="parameter"><code>lock</code></em> для чтения. Могут быть бесконечные параллельные блокировки для одновременного чтения <a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a>. Если <em class="parameter"><code>lock</code></em> уже заблокирован для записи другим потоком или если другой поток уже ожидает блокировки <em class="parameter"><code>lock</code></em> для записи, эта функция будет блокирована пока <em class="parameter"><code>lock</code></em> не разблокирует другой поток записи и никакие другие потоки не ожидают блокировки <em class="parameter"><code>lock</code></em>. Эта блокировка должна разблокироваться с помощью <a href="glib-Threads.html#g-static-rw-lock-reader-unlock"><code class="function">g_static_rw_lock_reader_unlock()</code></a>.
</p>
<p>
<a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a> не имеет рекурсии. Это может показаться возможным для рекурсивной блокировки чтения, но может привести к зависанию из-за привилегий "писателя".
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>lock</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a> для блокировки чтения.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2592776"></a><h3>
<a name="g-static-rw-lock-reader-trylock"></a>g_static_rw_lock_reader_trylock ()</h3>
<a class="indexterm" name="id2592789"></a><pre class="programlisting"><a href="glib-Basic-Types.html#gboolean">gboolean</a>    g_static_rw_lock_reader_trylock (<a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a> *lock);</pre>
<p>
Пытается блокировать <em class="parameter"><code>lock</code></em> для чтения. Если <em class="parameter"><code>lock</code></em> уже заблокирован для записи другим потоком или другой поток уже ожидает блокировку <em class="parameter"><code>lock</code></em> для записи, немедленно возвращает <a href="glib-Standard-Macros.html#FALSE:CAPS"><code class="literal">FALSE</code></a>. Иначе блокирует
<em class="parameter"><code>lock</code></em> для чтения и возвращает <a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>. Эта блокировка должна разблокироваться с помощью <a href="glib-Threads.html#g-static-rw-lock-reader-unlock"><code class="function">g_static_rw_lock_reader_unlock()</code></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>lock</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a> для блокирования чтения.
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>
<a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>, если <em class="parameter"><code>lock</code></em> можно блокировать для чтения.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2592929"></a><h3>
<a name="g-static-rw-lock-reader-unlock"></a>g_static_rw_lock_reader_unlock ()</h3>
<a class="indexterm" name="id2592943"></a><pre class="programlisting">void        g_static_rw_lock_reader_unlock  (<a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a> *lock);</pre>
<p>
Разблокирует <em class="parameter"><code>lock</code></em>. Если поток ожидает блокировку <em class="parameter"><code>lock</code></em> для записи и все блокировки для чтения были разблокированы, 
ожидающий поток пробуждается и может заблокировать <em class="parameter"><code>lock</code></em> для записи.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>lock</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a> для разблокирования после чтения.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2593019"></a><h3>
<a name="g-static-rw-lock-writer-lock"></a>g_static_rw_lock_writer_lock ()</h3>
<a class="indexterm" name="id2593032"></a><pre class="programlisting">void        g_static_rw_lock_writer_lock    (<a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a> *lock);</pre>
<p>
Блокирует <em class="parameter"><code>lock</code></em> для записи. Если <em class="parameter"><code>lock</code></em> уже заблокирован для записи или чтения другим потоком, эта функция блокируется до тех пор пока <em class="parameter"><code>lock</code></em> полностью не разблокируется а затем блокирует <em class="parameter"><code>lock</code></em> для записи. Пока эта функция ожидает блокировки <em class="parameter"><code>lock</code></em>, другие потоки не могут блокировать <em class="parameter"><code>lock</code></em> для чтения. Когда <em class="parameter"><code>lock</code></em> заблокирован для записи, другие потоки не могут блокировать <em class="parameter"><code>lock</code></em> (не для чтения не для записи). Эта блокировка должна разблокироваться с помощью <a href="glib-Threads.html#g-static-rw-lock-writer-unlock"><code class="function">g_static_rw_lock_writer_unlock()</code></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>lock</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a> блокируемая для записи.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2593151"></a><h3>
<a name="g-static-rw-lock-writer-trylock"></a>g_static_rw_lock_writer_trylock ()</h3>
<a class="indexterm" name="id2593165"></a><pre class="programlisting"><a href="glib-Basic-Types.html#gboolean">gboolean</a>    g_static_rw_lock_writer_trylock (<a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a> *lock);</pre>
<p>
Пытается блокировать <em class="parameter"><code>lock</code></em> для записи. Если <em class="parameter"><code>lock</code></em> уже заблокирован (для записи или чтенияg) другим потоком, она немедленно возвращает <a href="glib-Standard-Macros.html#FALSE:CAPS"><code class="literal">FALSE</code></a>. 
Иначе блокирует <em class="parameter"><code>lock</code></em> для записи и возвращает <a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>. 
Эта блокировка должна быть разблокирована с помощью <a href="glib-Threads.html#g-static-rw-lock-writer-unlock"><code class="function">g_static_rw_lock_writer_unlock()</code></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>lock</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a> блокируемая для записи.
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>
<a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>, если <em class="parameter"><code>lock</code></em> может блокироваться для записи.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2593299"></a><h3>
<a name="g-static-rw-lock-writer-unlock"></a>g_static_rw_lock_writer_unlock ()</h3>
<a class="indexterm" name="id2593312"></a><pre class="programlisting">void        g_static_rw_lock_writer_unlock  (<a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a> *lock);</pre>
<p>
Разблокирует <em class="parameter"><code>lock</code></em>. Если поток ожидает блокировки <em class="parameter"><code>lock</code></em> для записи и все блокировки для чтения разблокированы, ожидающий поток просыпается и может блокировать <em class="parameter"><code>lock</code></em> для записи. Если не тпотоков ожидающих блокировки <em class="parameter"><code>lock</code></em> для записи, а некоторые потоки ожидают блокировку <em class="parameter"><code>lock</code></em> для чтения, ожидающие потоки просыпаются и могут блокировать <em class="parameter"><code>lock</code></em> для чтения.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>lock</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a> для разблокирования после записи.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2593409"></a><h3>
<a name="g-static-rw-lock-free"></a>g_static_rw_lock_free ()</h3>
<a class="indexterm" name="id2593422"></a><pre class="programlisting">void        g_static_rw_lock_free           (<a href="glib-Threads.html#GStaticRWLock">GStaticRWLock</a> *lock);</pre>
<p>
Освобождает все ресурсы распределённые для <em class="parameter"><code>lock</code></em>. 
</p>
<p>
Вы не должны вызывать эту функцию для <a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a> с безграничным жизненным циклом, 
то есть для объектов объявленных статическими 'static', но если <a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a> является частью структуры и  структура освобождается, то вы также должны освободить <a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>lock</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticRWLock"><span class="type">GStaticRWLock</span></a> для освобождения.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2593514"></a><h3>
<a name="GCond"></a>GCond</h3>
<a class="indexterm" name="id2593527"></a><pre class="programlisting">typedef struct _GCond GCond;</pre>
<p>
Структура <a href="glib-Threads.html#GCond"><span class="type">GCond</span></a> является закрытой структурой данных представляющих условие. Потоки могут блокироваться на <a href="glib-Threads.html#GCond"><span class="type">GCond</span></a> если они обнаружат определённое ложное условие. Если другие потоки изменяют состояние этого условия они сообщают <a href="glib-Threads.html#GCond"><span class="type">GCond</span></a> и тогда ожидающий поток просыпается.
</p>
<p>
</p>
<div class="example">
<a name="id2593572"></a><p class="title"><b>Пример&#160;9.&#160;Использование GCond для блокировки потока пока условие не удавлетворено</b></p>
<pre class="programlisting">
GCond* data_cond = NULL;   /* Должен быть где-нибудь инициализирован */
GMutex* data_mutex = NULL; /* Должен быть где-нибудь инициализирован */
gpointer current_data = NULL;

void push_data (gpointer data)
{
  g_mutex_lock (data_mutex);
  current_data = data;
  g_cond_signal (data_cond);
  g_mutex_unlock (data_mutex);
}

gpointer pop_data ()
{
  gpointer data;

  g_mutex_lock (data_mutex);
  while (!current_data)
      g_cond_wait (data_cond, data_mutex);
  data = current_data;
  current_data = NULL;
  g_mutex_unlock (data_mutex);
  return data;
}
</pre>
</div>
<p>
</p>
<p>
Теперь, каждый раз когда поток вызывает <code class="function"><code class="function">pop_data()</code></code>, он будет ждать пока current_data будет не-<a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a>, то есть пока какой-нибудь поток вызовет <code class="function"><code class="function">push_data()</code></code>.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Важно использовать <a href="glib-Threads.html#g-cond-wait"><code class="function">g_cond_wait()</code></a> и <a href="glib-Threads.html#g-cond-timed-wait"><code class="function">g_cond_timed_wait()</code></a>
функции только внутри цикла который проверяет правильность условия. 
Не гарантируется что ожидающий поток будет искать условие выполнения после пробуждения, 
даже если сообщающий поток сбросит условие в это состояние: другой поток может переключить 
условие прежде чем ожидающий поток проснётся, даже если само условие защищено с помощью <a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a>, как описано выше.
</p>
</div>
<p>
<a href="glib-Threads.html#GCond"><span class="type">GCond</span></a> доступна только через функции описанные далее.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Все <code class="function">g_cond_*</code> функции фактически являются макросами. 
Однако, за исключением взятия адреса, вы можете использовать их как функции.
</p>
</div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2593713"></a><h3>
<a name="g-cond-new"></a>g_cond_new ()</h3>
<a class="indexterm" name="id2593725"></a><pre class="programlisting"><a href="glib-Threads.html#GCond">GCond</a>*      g_cond_new                      ();</pre>
<p>
Создаёт новую <a href="glib-Threads.html#GCond"><span class="type">GCond</span></a>. Эта функция прерывается, если не была вызвана <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>новая <a href="glib-Threads.html#GCond"><span class="type">GCond</span></a>.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2593789"></a><h3>
<a name="g-cond-signal"></a>g_cond_signal ()</h3>
<a class="indexterm" name="id2593801"></a><pre class="programlisting">void        g_cond_signal                   (<a href="glib-Threads.html#GCond">GCond</a> *cond);</pre>
<p>
Если потоки ожидают условие <em class="parameter"><code>cond</code></em>, только один из них пробуждается. Хорошая практика удерживать блокировку ожидающего потока пока вызывается эта функция, хотя и необязательно.
</p>
<p>
Эта функция может использоваться даже если <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> не была вызвана, в этом случае она ничего не делает.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>cond</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GCond"><span class="type">GCond</span></a>.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2593880"></a><h3>
<a name="g-cond-broadcast"></a>g_cond_broadcast ()</h3>
<a class="indexterm" name="id2593893"></a><pre class="programlisting">void        g_cond_broadcast                (<a href="glib-Threads.html#GCond">GCond</a> *cond);</pre>
<p>
Если потоки ожидают условие <em class="parameter"><code>cond</code></em>, все они пробуждаются. Хорошей практикой является блокирование ожидающих потоков некоторым взаимоисключением (mutex), пока вызывается эта функция, хотя не обязательно.
</p>
<p>
Эта функция может использоваться даже если <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> не была вызвана, в этом случае она ничего не делает.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>cond</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GCond"><span class="type">GCond</span></a>.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2593971"></a><h3>
<a name="g-cond-wait"></a>g_cond_wait ()</h3>
<a class="indexterm" name="id2593984"></a><pre class="programlisting">void        g_cond_wait                     (<a href="glib-Threads.html#GCond">GCond</a> *cond,
                                             <a href="glib-Threads.html#GMutex">GMutex</a> *mutex);</pre>
<p>
Заставляет поток ждать условие <em class="parameter"><code>cond</code></em>. Взаимоисключение <em class="parameter"><code>mutex</code></em> разблокируется перед отключением и блокируется после возобнавления.
</p>
<p>
Эта функция может использоваться даже если <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> не была вызвана, в этом случае она немедленно возвращает результат.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>cond</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GCond"><span class="type">GCond</span></a>.
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a>, который в настоящее время заблокирован.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2594096"></a><h3>
<a name="g-cond-timed-wait"></a>g_cond_timed_wait ()</h3>
<a class="indexterm" name="id2594110"></a><pre class="programlisting"><a href="glib-Basic-Types.html#gboolean">gboolean</a>    g_cond_timed_wait               (<a href="glib-Threads.html#GCond">GCond</a> *cond,
                                             <a href="glib-Threads.html#GMutex">GMutex</a> *mutex,
                                             <a href="glib-Date-and-Time-Functions.html#GTimeVal">GTimeVal</a> *abs_time);</pre>
<p>
Заставляет поток ждать условия пробуждения <em class="parameter"><code>cond</code></em>, но не дольше чем определено параметром <em class="parameter"><code>abs_time</code></em>. Взаимоисключение <em class="parameter"><code>mutex</code></em> разблокируется перед отключением и блокируется снова после возобнавления.
</p>
<p>
Если <em class="parameter"><code>abs_time</code></em> равен <a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a>, <a href="glib-Threads.html#g-cond-timed-wait"><code class="function">g_cond_timed_wait()</code></a> действует как <a href="glib-Threads.html#g-cond-wait"><code class="function">g_cond_wait()</code></a>.
</p>
<p>
Эта функция может использоваться даже если <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> не была вызвана, в этом случае она немедленно возвращает <a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a>.
</p>
<p>
Для простоты вычисления <em class="parameter"><code>abs_time</code></em> может использоваться комбинация <a href="glib-Date-and-Time-Functions.html#g-get-current-time"><code class="function">g_get_current_time()</code></a>
и <a href="glib-Date-and-Time-Functions.html#g-time-val-add"><code class="function">g_time_val_add()</code></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>cond</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GCond"><span class="type">GCond</span></a>.
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>mutex</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a> который заблокирован в текущий момент.
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>abs_time</code></em>&#160;:</span></td>
<td><a href="glib-Date-and-Time-Functions.html#GTimeVal"><span class="type">GTimeVal</span></a>, определяющая максимальное время ожидания.
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>
<a href="glib-Standard-Macros.html#TRUE:CAPS"><code class="literal">TRUE</code></a> если об условии <em class="parameter"><code>cond</code></em> было сообщено, или <a href="glib-Standard-Macros.html#FALSE:CAPS"><code class="literal">FALSE</code></a> при истечении времени ожидания.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2594377"></a><h3>
<a name="g-cond-free"></a>g_cond_free ()</h3>
<a class="indexterm" name="id2594390"></a><pre class="programlisting">void        g_cond_free                     (<a href="glib-Threads.html#GCond">GCond</a> *cond);</pre>
<p>
Уничтожает <a href="glib-Threads.html#GCond"><span class="type">GCond</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>cond</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GCond"><span class="type">GCond</span></a>.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2594452"></a><h3>
<a name="GPrivate"></a>GPrivate</h3>
<a class="indexterm" name="id2594464"></a><pre class="programlisting">typedef struct _GPrivate GPrivate;</pre>
<p>
Структура <a href="glib-Threads.html#GPrivate"><span class="type">GPrivate</span></a> является закрытой структурой данных представляющая индивидуальные ключевые данные для потоков. Потоки таким образом могут устанавливать и получать указатели которые индивидуальны для текущего потока. 
Возьмём наш выше приведенный пример <code class="function"><code class="function">give_me_next_number()</code></code>.
Предположим что мы не хотим чтобы переменная <code class="literal">current_number</code> 
распределялясь между потоками, а вместо этого была бы индивидуальной для каждого потока. 
Это можно сделать следующим образом:
</p>
<div class="example">
<a name="id2594512"></a><p class="title"><b>Пример&#160;10.&#160;Using GPrivate for per-thread data</b></p>
<pre class="programlisting">
  GPrivate* current_number_key = NULL; /* Должна быть где-нибудь инициализирована */
                                       /* с помощью g_private_new (g_free); */

  int give_me_next_number ()
  {
    int *current_number = g_private_get (current_number_key);

    if (!current_number)
    {
      current_number = g_new (int,1);
      *current_number = 0;
      g_private_set (current_number_key, current_number);
    }
    *current_number = calc_next_number (*current_number); 
    return *current_number;
  }
</pre>
</div>
<p>
</p>
<p>
Здесь указатель принадлежащий ключу <code class="literal">current_number_key</code> 
читается. Если он равен <a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a>, то не устанавливается. Затем получаем память для целочисленного значения, 
привязываем эту память к указателю и записываем указатель обратно. 
Теперь мы имеем целочисленное значение которое индивидуально для текущего потока.
</p>
<p>
К структуре <a href="glib-Threads.html#GPrivate"><span class="type">GPrivate</span></a> должны обращаться только следующие функции.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Все функции <code class="function">g_private_*</code> фактически являются макросами. 
Однако, за исключением взятия адреса, вы можете использовать их как обычные функции.
</p>
</div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2594587"></a><h3>
<a name="g-private-new"></a>g_private_new ()</h3>
<a class="indexterm" name="id2594600"></a><pre class="programlisting"><a href="glib-Threads.html#GPrivate">GPrivate</a>*   g_private_new                   (<a href="glib-Datasets.html#GDestroyNotify">GDestroyNotify</a> destructor);</pre>
<p>
Создаёт новую <a href="glib-Threads.html#GPrivate"><span class="type">GPrivate</span></a>. Если <em class="parameter"><code>destructor</code></em> не-<a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a>, то указывает на разрушающую функцию. 
Каждый раз когда поток завершается и ключевой указатель соответствующий этому образцу <a href="glib-Threads.html#GPrivate"><span class="type">GPrivate</span></a> не является <a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a>, разрушающая функция вызывается с этим указателем в качестве параметра.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
<em class="parameter"><code>destructor</code></em> используется иначе чем <em class="parameter"><code>notify</code></em> в
<a href="glib-Threads.html#g-static-private-set"><code class="function">g_static_private_set()</code></a>.
</p>
</div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
<a href="glib-Threads.html#GPrivate"><span class="type">GPrivate</span></a> не может освобождаться. 
Вместо этого используйте её повторно, или используйте <a href="glib-Threads.html#GStaticPrivate"><span class="type">GStaticPrivate</span></a>.
</p>
</div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Эта функция прерывается если <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> не была вызвана.
</p>
</div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>destructor</code></em>&#160;:</span></td>
<td>функция для уничтожения ключевых данных в <a href="glib-Threads.html#GPrivate"><span class="type">GPrivate</span></a> когда поток завершён.
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>новая <a href="glib-Threads.html#GPrivate"><span class="type">GPrivate</span></a>.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2594791"></a><h3>
<a name="g-private-get"></a>g_private_get ()</h3>
<a class="indexterm" name="id2594804"></a><pre class="programlisting"><a href="glib-Basic-Types.html#gpointer">gpointer</a>    g_private_get                   (<a href="glib-Threads.html#GPrivate">GPrivate</a> *private_key);</pre>
<p>
Возвращает ключевой указатель <em class="parameter"><code>private_key</code></em> для текущего потока.
Если <a href="glib-Threads.html#g-private-set"><code class="function">g_private_set()</code></a> не была вызвана для текущего <em class="parameter"><code>private_key</code></em> и потока, этот указатель будет <a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a>.
</p>
<p>
Эта функция может использоваться даже если <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> не была вызвана, 
в этом случае она возвращает значение <em class="parameter"><code>private_key</code></em> 
приведённый к <a href="glib-Basic-Types.html#gpointer"><span class="type">gpointer</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>private_key</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GPrivate"><span class="type">GPrivate</span></a>.
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>соответсвующий указатель.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2594932"></a><h3>
<a name="g-private-set"></a>g_private_set ()</h3>
<a class="indexterm" name="id2594945"></a><pre class="programlisting">void        g_private_set                   (<a href="glib-Threads.html#GPrivate">GPrivate</a> *private_key,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> data);</pre>
<p>
Устанавливает ключевой указатель <em class="parameter"><code>private_key</code></em> для текущего потока.
</p>
<p>
Эта функция может использоваться даже если <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> не была вызвана, 
в этом случае будет установлен <em class="parameter"><code>private_key</code></em> в <em class="parameter"><code>data</code></em> приведенный к <a href="glib-Threads.html#GPrivate"><span class="type">GPrivate</span></a>*.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>private_key</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GPrivate"><span class="type">GPrivate</span></a>.
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>data</code></em>&#160;:</span></td>
<td>новый указатель.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2595062"></a><h3>
<a name="GStaticPrivate"></a>GStaticPrivate</h3>
<a class="indexterm" name="id2595075"></a><pre class="programlisting">typedef struct {
} GStaticPrivate;
</pre>
<p>
<a href="glib-Threads.html#GStaticPrivate"><span class="type">GStaticPrivate</span></a> 
работает также как <a href="glib-Threads.html#GPrivate"><span class="type">GPrivate</span></a>, 
но имеет одно существенное приимущество. Она не должна создаваться во время выполнения как 
<a href="glib-Threads.html#GPrivate"><span class="type">GPrivate</span></a>, а может быть определена во время компиляции. Это подобно различию между 
<a href="glib-Threads.html#GMutex"><span class="type">GMutex</span></a> и <a href="glib-Threads.html#GStaticMutex"><span class="type">GStaticMutex</span></a>. Теперь взглянем на наш пример 
<code class="function"><code class="function">give_me_next_number()</code></code> с использованием <span class="type">GStaticPrivate:</span>
</p>
<p>
</p>
<div class="example">
<a name="id2595160"></a><p class="title"><b>Пример&#160;11.&#160;Использование GStaticPrivate в качестве потоковых данных</b></p>
<pre class="programlisting">
  int give_me_next_number ()
  {
    static GStaticPrivate current_number_key = G_STATIC_PRIVATE_INIT;
    int *current_number = g_static_private_get (&amp;current_number_key);

    if (!current_number)
    {
      current_number = g_new (int,1);
      *current_number = 0;
      g_static_private_set (&amp;current_number_key, current_number, g_free);
    }
    *current_number = calc_next_number (*current_number); 
    return *current_number;
  }
</pre>
</div>
<p>
</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2595190"></a><h3>
<a name="G-STATIC-PRIVATE-INIT:CAPS"></a>G_STATIC_PRIVATE_INIT</h3>
<a class="indexterm" name="id2595203"></a><pre class="programlisting">#define G_STATIC_PRIVATE_INIT 
</pre>
<p>
Все <a href="glib-Threads.html#GStaticPrivate"><span class="type">GStaticPrivate</span></a> перед использованием должны быть инициализированы этим макросом.
</p>
<p>
</p>
<div class="informalexample"><pre class="programlisting">
GStaticPrivate my_private = G_STATIC_PRIVATE_INIT;
</pre></div>
<p>
</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2595241"></a><h3>
<a name="g-static-private-init"></a>g_static_private_init ()</h3>
<a class="indexterm" name="id2595254"></a><pre class="programlisting">void        g_static_private_init           (<a href="glib-Threads.html#GStaticPrivate">GStaticPrivate</a> *private_key);</pre>
<p>
Инициализирует <em class="parameter"><code>private_key</code></em>. Альтернативно вы можете инициализировать его с помощью
<a href="glib-Threads.html#G-STATIC-PRIVATE-INIT:CAPS"><span class="type">G_STATIC_PRIVATE_INIT</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>private_key</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticPrivate"><span class="type">GStaticPrivate</span></a> для инициализации.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2595325"></a><h3>
<a name="g-static-private-get"></a>g_static_private_get ()</h3>
<a class="indexterm" name="id2595338"></a><pre class="programlisting"><a href="glib-Basic-Types.html#gpointer">gpointer</a>    g_static_private_get            (<a href="glib-Threads.html#GStaticPrivate">GStaticPrivate</a> *private_key);</pre>
<p>
Работает также как <a href="glib-Threads.html#g-private-get"><code class="function">g_private_get()</code></a> только для <a href="glib-Threads.html#GStaticPrivate"><span class="type">GStaticPrivate</span></a>.
</p>
<p>
Эта функция работает даже если <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> не была вызвана.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>private_key</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticPrivate"><span class="type">GStaticPrivate</span></a>.
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>соответствующий указатель.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2595438"></a><h3>
<a name="g-static-private-set"></a>g_static_private_set ()</h3>
<a class="indexterm" name="id2595451"></a><pre class="programlisting">void        g_static_private_set            (<a href="glib-Threads.html#GStaticPrivate">GStaticPrivate</a> *private_key,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> data,
                                             <a href="glib-Datasets.html#GDestroyNotify">GDestroyNotify</a> notify);</pre>
<p>
Устанавливает ключевой указатель <em class="parameter"><code>private_key</code></em> для текущего потока и функцию <em class="parameter"><code>notify</code></em> вызываемую с этим указателем (<a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a> или не-<a href="glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a>),
каждый раз когда указатель установлен снова или каждый раз когда текущий поток завершается.
</p>
<p>
Эта функция работает даже если <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> не была вызвана. 
Если <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a> вызвана позже, то <em class="parameter"><code>data</code></em> ключевые для <em class="parameter"><code>private_key</code></em> будут унаследованы только основным потоком, то есть тем который вызван <a href="glib-Threads.html#g-thread-init"><code class="function">g_thread_init()</code></a>.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
<em class="parameter"><code>notify</code></em> используется иначе чем <em class="parameter"><code>destructor</code></em> в
<a href="glib-Threads.html#g-private-new"><code class="function">g_private_new()</code></a>.
</p>
</div>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>private_key</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GStaticPrivate"><span class="type">GStaticPrivate</span></a>.
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>data</code></em>&#160;:</span></td>
<td>новый указатель.
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>notify</code></em>&#160;:</span></td>
<td>функция вызываемая с указателем каждый раз когда завершается текущий поток или указатель устанавливается снова.
</td>
</tr>
</tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2595665"></a><h3>
<a name="g-static-private-free"></a>g_static_private_free ()</h3>
<a class="indexterm" name="id2595678"></a><pre class="programlisting">void        g_static_private_free           (<a href="glib-Threads.html#GStaticPrivate">GStaticPrivate</a> *private_key);</pre>
<p>
Освобождает все ресурсы распределённые для <em class="parameter"><code>private_key</code></em>. 
</p>
<p>
Вы не должны вызывать эту функцию для <a href="glib-Threads.html#GStaticPrivate"><span class="type">GStaticPrivate</span></a> с неограниченным жизненным циклом, то есть для объявленной статично 'static', но если <a href="glib-Threads.html#GStaticPrivate"><span class="type">GStaticPrivate</span></a> 
член структуры и структура освобождается,
вы должны также освободить <a href="glib-Threads.html#GStaticPrivate"><span class="type">GStaticPrivate</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><span class="term"><em class="parameter"><code>private_key</code></em>&#160;:</span></td>
<td> освобождаемая <a href="glib-Threads.html#GStaticPrivate"><span class="type">GStaticPrivate</span></a>.
</td>
</tr></tbody>
</table></div>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2595771"></a><h3>
<a name="GOnce"></a>GOnce</h3>
<a class="indexterm" name="id2595786"></a><pre class="programlisting">typedef struct {
  volatile GOnceStatus status;
  volatile gpointer retval;
} GOnce;
</pre>
<p>
Структура <span class="structname">GOnce</span> контролирует одноразовую функцию инициализации. 
Любые одноразовые функции инициализации должны иметь собственную уникальную структуру 
<span class="structname">GOnce</span>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term">volatile&#160;<a href="glib-Threads.html#GOnceStatus">GOnceStatus</a>&#160;<em class="structfield"><code>status</code></em>;</span></td>
<td>состояние <a href="glib-Threads.html#GOnce"><span class="type">GOnce</span></a>
</td>
</tr>
<tr>
<td><span class="term">volatile&#160;<a href="glib-Basic-Types.html#gpointer">gpointer</a>&#160;<em class="structfield"><code>retval</code></em>;</span></td>
<td>возвращаемое значение, если <em class="parameter"><code>status</code></em>
равен <a href="glib-Threads.html#G-ONCE-STATUS-READY:CAPS"><code class="literal">G_ONCE_STATUS_READY</code></a>
</td>
</tr>
</tbody>
</table></div>
<p>Начиная с версии 2.4
</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2595891"></a><h3>
<a name="GOnceStatus"></a>enum GOnceStatus</h3>
<a class="indexterm" name="id2595905"></a><pre class="programlisting">typedef enum
{
  G_ONCE_STATUS_NOTCALLED,
  G_ONCE_STATUS_PROGRESS,
  G_ONCE_STATUS_READY  
} GOnceStatus;
</pre>
<p>
Возвможные состояния одноразовых функций инициализации контролируемые структурой <a href="glib-Threads.html#GOnce"><span class="type">GOnce</span></a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><a name="G-ONCE-STATUS-NOTCALLED:CAPS"></a><code class="literal">G_ONCE_STATUS_NOTCALLED</code></span></td>
<td>функция не была вызвана.
</td>
</tr>
<tr>
<td><span class="term"><a name="G-ONCE-STATUS-PROGRESS:CAPS"></a><code class="literal">G_ONCE_STATUS_PROGRESS</code></span></td>
<td>вызов функции происходит в текущий момент.
</td>
</tr>
<tr>
<td><span class="term"><a name="G-ONCE-STATUS-READY:CAPS"></a><code class="literal">G_ONCE_STATUS_READY</code></span></td>
<td>функия вызвана.
</td>
</tr>
</tbody>
</table></div>
<p>Начиная с версии 2.4
</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2596010"></a><h3>
<a name="G-ONCE-INIT:CAPS"></a>G_ONCE_INIT</h3>
<a class="indexterm" name="id2596024"></a><pre class="programlisting">#define G_ONCE_INIT { G_ONCE_STATUS_NOTCALLED, NULL }
</pre>
<p>
<a href="glib-Threads.html#GOnce"><span class="type">GOnce</span></a> должна быть инициализирована 
перед использованием с помощью этого макроса. 
</p>
<p>
</p>
<div class="informalexample"><pre class="programlisting">
GOnce my_once = G_ONCE_INIT;
</pre></div>
<p>
</p>
<p>Начиная с версии 2.4
</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2596065"></a><h3>
<a name="g-once"></a>g_once()</h3>
<a class="indexterm" name="id2596080"></a><pre class="programlisting">#define     g_once(once, func, arg)</pre>
<p>
Первый вызов с полученной структурой <a href="glib-Threads.html#GOnce"><span class="type">GOnce</span></a> struct вызывает функцию <em class="parameter"><code>func</code></em> 
с полученным аргументом. Последующие вызовы <a href="glib-Threads.html#g-once"><code class="function">g_once()</code></a>  с той же структурой <a href="glib-Threads.html#GOnce"><span class="type">GOnce</span></a> не вызывают <em class="parameter"><code>func</code></em> снова, а возвращают сохранённый результат первого вызова. 
Возвращаемое из <a href="glib-Threads.html#g-once"><code class="function">g_once()</code></a> состояние <em class="parameter"><code>once</code></em> будет 
<a href="glib-Threads.html#G-ONCE-STATUS-READY:CAPS"><code class="literal">G_ONCE_STATUS_READY</code></a>.
</p>
<p>
Например, взаимоисключение или ключевые потоковые данные должны быть созданы только один раз. 
В потоковом окружении, вызов <a href="glib-Threads.html#g-once"><code class="function">g_once()</code></a> гарантирует что инициализация преобразована в последовательную форму через множество потоков.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Примечание</h3>
<p>
Рекурсивный вызов <a href="glib-Threads.html#g-once"><code class="function">g_once()</code></a> на той же самой структуре <a href="glib-Threads.html#GOnce"><span class="type">GOnce</span></a> в <em class="parameter"><code>func</code></em> приведёт к зависанию.
</p>
</div>
<p>
</p>
<div class="informalexample"><pre class="programlisting">
gpointer 
<code class="function">get_debug_flags()</code>
{
  static GOnce my_once = G_ONCE_INIT;
  
  g_once (&amp;my_once, parse_debug_flags, NULL);

  return my_once.retval;
}
</pre></div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>once</code></em>&#160;:</span></td>
<td>структура <a href="glib-Threads.html#GOnce"><span class="type">GOnce</span></a>
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>func</code></em>&#160;:</span></td>
<td><a href="glib-Threads.html#GThreadFunc"><span class="type">GThreadFunc</span></a> функция ассоциированная с <em class="parameter"><code>once</code></em>. Эта функция вызывается только один раз, 
не зависимо от количества раз помещения структуры <a href="glib-Threads.html#GOnce"><span class="type">GOnce</span></a> в <a href="glib-Threads.html#g-once"><code class="function">g_once()</code></a> .
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>arg</code></em>&#160;:</span></td>
<td> данные помещаемые в <em class="parameter"><code>func</code></em>
</td>
</tr>
</tbody>
</table></div>
<p>Начиная с версии 2.4
</p>
</div>
</div>
<div class="refsect1" lang="en">
<a name="id2596339"></a><h2>Смотрите также</h2>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><a href="glib-Thread-Pools.html#GThreadPool"><span class="type">GThreadPool</span></a></span></td>
<td><p>Объединённые потоки.</p></td>
</tr>
<tr>
<td><span class="term"><a href="glib-Asynchronous-Queues.html#GAsyncQueue"><span class="type">GAsyncQueue</span></a></span></td>
<td><p>Отправка асинхронных сообщений между потоками.</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</div>
</div>
</body>
</html>
