<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Memory Slices</title>
<meta name="generator" content="DocBook XSL Stylesheets V1.68.1">
<link rel="start" href="index.html" title="GLib Reference Manual">
<link rel="up" href="glib-data-types.html" title="GLib Data Types">
<link rel="prev" href="glib-data-types.html" title="GLib Data Types">
<link rel="next" href="glib-Memory-Chunks.html" title="Memory Chunks">
<meta name="generator" content="GTK-Doc V1.7 (XML mode)">
<link rel="stylesheet" href="style.css" type="text/css">
<link rel="chapter" href="glib.html" title="GLib Overview">
<link rel="chapter" href="glib-fundamentals.html" title="GLib Fundamentals">
<link rel="chapter" href="glib-core.html" title="GLib Core Application Support">
<link rel="chapter" href="glib-utilities.html" title="GLib Utilities">
<link rel="chapter" href="glib-data-types.html" title="GLib Data Types">
<link rel="chapter" href="tools.html" title="GLib Tools">
<link rel="index" href="ix01.html" title="Index">
<link rel="index" href="ix02.html" title="Index of deprecated symbols">
<link rel="index" href="ix03.html" title="Index of new symbols in 2.2">
<link rel="index" href="ix04.html" title="Index of new symbols in 2.4">
<link rel="index" href="ix05.html" title="Index of new symbols in 2.6">
<link rel="index" href="ix06.html" title="Index of new symbols in 2.8">
<link rel="index" href="ix07.html" title="Index of new symbols in 2.10">
<link rel="index" href="ix08.html" title="Index of new symbols in 2.12">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table class="navigation" id="top" width="100%" summary="Navigation header" cellpadding="2" cellspacing="2">
<tr valign="middle">
<td><a accesskey="p" href="glib-data-types.html"><img src="left.png" width="24" height="24" border="0" alt="Prev"></a></td>
<td><a accesskey="u" href="glib-data-types.html"><img src="up.png" width="24" height="24" border="0" alt="Up"></a></td>
<td><a accesskey="h" href="index.html"><img src="home.png" width="24" height="24" border="0" alt="Home"></a></td>
<th width="100%" align="center">Справочное описание GLib</th>
<td><a accesskey="n" href="glib-Memory-Chunks.html"><img src="right.png" width="24" height="24" border="0" alt="Next"></a></td>
</tr>
<tr><td colspan="5" class="shortcuts"><nobr><a href="#id2880348" class="shortcut">Начало</a>
                  &#160;|&#160;
                  <a href="#id2880510" class="shortcut">Описание</a></nobr></td></tr>
</table>
<div class="refentry" lang="en">
<a name="glib-Memory-Slices"></a><div class="titlepage"></div>
<div class="refnamediv"><table width="100%"><tr>
<td valign="top">
<h2>
<a name="id2880348"></a><span class="refentrytitle">Memory Slices</span>
</h2>
<p>Memory Slices &#8212; Эффективный способ распределения групп эквивалентных по размеру участков памяти.</p>
</td>
<td valign="top" align="right"></td>
</tr></table></div>
<div class="refsynopsisdiv">
<h2>Краткое описание</h2>
<pre class="synopsis">

#include &lt;glib.h&gt;


<a href="glib-Basic-Types.html#gpointer">gpointer</a>    <a href="glib-Memory-Slices.html#g-slice-alloc">g_slice_alloc</a>                   (<a href="glib-Basic-Types.html#gsize">gsize</a> block_size);
<a href="glib-Basic-Types.html#gpointer">gpointer</a>    <a href="glib-Memory-Slices.html#g-slice-alloc0">g_slice_alloc0</a>                  (<a href="glib-Basic-Types.html#gsize">gsize</a> block_size);
void        <a href="glib-Memory-Slices.html#g-slice-free1">g_slice_free1</a>                   (<a href="glib-Basic-Types.html#gsize">gsize</a> block_size,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> mem_block);
void        <a href="glib-Memory-Slices.html#g-slice-free-chain-with-offset">g_slice_free_chain_with_offset</a>  (<a href="glib-Basic-Types.html#gsize">gsize</a> block_size,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> mem_chain,
                                             <a href="glib-Basic-Types.html#gsize">gsize</a> next_offset);

#define     <a href="glib-Memory-Slices.html#g-slice-new">g_slice_new</a>                     (type)
#define     <a href="glib-Memory-Slices.html#g-slice-new0">g_slice_new0</a>                    (type)
#define     <a href="glib-Memory-Slices.html#g-slice-free">g_slice_free</a>                    (type, mem)
#define     <a href="glib-Memory-Slices.html#g-slice-free-chain">g_slice_free_chain</a>              (type, mem_chain, next)

</pre>
</div>
<div class="refsect1" lang="en">
<a name="id2880510"></a><h2>Описание</h2>
<p>
Слайсы памяти обеспечивают пространственно-эффективный и многопроцессорно-масштабируемый путь для распределения равных по размеру 
частей памяти, так же как оригинальный <span class="type">GMemChunks</span> (from GLib &lt;= 2.8), избегая чрезмерной траты памяти, 
потери масштабируемости и проблем выполнения.
</p>
<p>
Для достижения этих целей, распределитель слайсов использует сложный, 
многоуровневый дизайн который был создан благодаря распределителю слайсов Bonwick's
<sup>[<a name="id2880543" href="#ftn.id2880543">5</a>]</sup>.
Он использует <code class="function">posix_memalign()</code> для оптимизированного 
распределения множества участков одинакового размера и имеет посредством потока 
свободные списки (так называемый уровень журналирования) 
для быстрого удовлетворения запросов распределения уже известных размеров структур. 
Это сопровождается дополнительным логическим кэшированием, чтобы иметь свободную память 
в течении некоторого времени перед возвращением в систему. Память которая не используется 
из-за ограничений выравнивания, используется для колоризации кэша 
(произвольное распределение адресов участка) для улучшенного использования кэша CPU. 
Кэширующий уровень распределителя слайсов самостоятельно адаптируется к высокой конкуренции 
блокирования для улучшения масштабируемости.
</p>
<p>
Распределитель слайсов может распределять небольшие блоки в два указателя, и в отличие от 
<code class="function">malloc()</code>, он не резервирует дополнительное пространство в блоке. 
Для блоков большого размера, <a href="glib-Memory-Slices.html#g-slice-new"><code class="function">g_slice_new()</code></a> 
и <a href="glib-Memory-Slices.html#g-slice-alloc"><code class="function">g_slice_alloc()</code></a> автоматически делегируют 
к системной реализации <code class="function">malloc()</code>. Для вновь создаваемого кода рекомендуется использовать новый 
<code class="literal">g_slice</code> API вместо <a href="glib-Memory-Allocation.html#g-malloc"><code class="function">g_malloc()</code></a> 
и подобных, пока объекты не изменяют размер в течении их жизненного цикла и размер объекта используемый во время распределения 
остаётся доступным когда освобождается.
</p>
<div class="example">
<a name="id2880655"></a><p class="title"><b>Пример&#160;1.&#160;Использование распределителя слайсов</b></p>
<pre class="programlisting">
  gchar *mem[10000];
  gint i;

  /* Распределяем 10000 блоков. */
  for (i = 0; i &lt; 10000; i++)
    {
      mem[i] = g_slice_alloc (50);

      /* Fill in the memory with some junk. */
      for (j = 0; j &lt; 50; j++)
	mem[i][j] = i * j;
    }

  /* Освобождаем все блоки. */
  for (i = 0; i &lt; 10000; i++)
    {
      g_slice_free1 (50, mem[i]);
    }
</pre>
</div>
<div class="example">
<a name="id2880676"></a><p class="title"><b>Пример&#160;2.&#160;Использование распределителя слайсов со структурами данных</b></p>
<pre class="programlisting">
  GRealArray *array;

  /* Распределяем один блок, используя макрос g_slice_new(). */
  array = g_slice_new (GRealArray);

  /* Теперь мы можем использовать массив как обычный указатель на структуру. */
  array-&gt;data            = NULL;
  array-&gt;len             = 0;
  array-&gt;alloc           = 0;
  array-&gt;zero_terminated = (zero_terminated ? 1 : 0);
  array-&gt;clear           = (clear ? 1 : 0);
  array-&gt;elt_size        = elt_size;

  /* Мы можем освобождать блок, поэтому он может использоваться многократно. */
  g_slice_free (GRealArray, array);
</pre>
</div>
</div>
<div class="refsect1" lang="en">
<a name="id2880700"></a><h2>Детали</h2>
<div class="refsect2" lang="en">
<a name="id2880710"></a><h3>
<a name="g-slice-alloc"></a>g_slice_alloc ()</h3>
<a class="indexterm" name="id2880725"></a><pre class="programlisting"><a href="glib-Basic-Types.html#gpointer">gpointer</a>    g_slice_alloc                   (<a href="glib-Basic-Types.html#gsize">gsize</a> block_size);</pre>
<p>
Распределяет блок памяти из распределителя слайсов.
Адрес полученного блока, как гарантируется, будет выравнен по крайней мере 2 * sizeof (void*).
Помните что основной механизм распределения слайсов может быть изменён с помощью переменной окружения 
<a href="glib-running.html#G_SLICE">G_SLICE=always-malloc</a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>block_size</code></em>&#160;:</span></td>
<td>количество байт для распределения
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>указатель на распределённую память block
</td>
</tr>
</tbody>
</table></div>
<p>Начиная с версии 2.10


</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2880800"></a><h3>
<a name="g-slice-alloc0"></a>g_slice_alloc0 ()</h3>
<a class="indexterm" name="id2880815"></a><pre class="programlisting"><a href="glib-Basic-Types.html#gpointer">gpointer</a>    g_slice_alloc0                  (<a href="glib-Basic-Types.html#gsize">gsize</a> block_size);</pre>
<p>
Распределяет блок памяти через <a href="glib-Memory-Slices.html#g-slice-alloc"><code class="function">g_slice_alloc()</code></a>
и инициализирует возвращаемую память 0.
Помните что основной механизм распределения слайсов может быть изменён с помощью переменной окружения 
<a href="glib-running.html#G_SLICE">G_SLICE=always-malloc</a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>block_size</code></em>&#160;:</span></td>
<td>количество байт для распределения
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>указатель на распределённый блок
</td>
</tr>
</tbody>
</table></div>
<p>Начиная с версии 2.10

</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2880898"></a><h3>
<a name="g-slice-free1"></a>g_slice_free1 ()</h3>
<a class="indexterm" name="id2880912"></a><pre class="programlisting">void        g_slice_free1                   (<a href="glib-Basic-Types.html#gsize">gsize</a> block_size,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> mem_block);</pre>
<p>
Освобождает блок памяти. Память должна быть распределена через
<a href="glib-Memory-Slices.html#g-slice-alloc"><code class="function">g_slice_alloc()</code></a> 
или <a href="glib-Memory-Slices.html#g-slice-alloc0"><code class="function">g_slice_alloc0()</code></a>,
а <em class="parameter"><code>block_size</code></em> должен соответствовать размеру определённому при распределении.
Помните что существующее поведение может быть изменено с помощью переменной окружения
<a href="glib-running.html#G_DEBUG">G_DEBUG=gc-friendly</a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>block_size</code></em>&#160;:</span></td>
<td>размер блока
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>mem_block</code></em>&#160;:</span></td>
<td>указатель на блок для освобождения
</td>
</tr>
</tbody>
</table></div>
<p>Начиная с версии 2.10

</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2881023"></a><h3>
<a name="g-slice-free-chain-with-offset"></a>g_slice_free_chain_with_offset ()</h3>
<a class="indexterm" name="id2881038"></a><pre class="programlisting">void        g_slice_free_chain_with_offset  (<a href="glib-Basic-Types.html#gsize">gsize</a> block_size,
                                             <a href="glib-Basic-Types.html#gpointer">gpointer</a> mem_chain,
                                             <a href="glib-Basic-Types.html#gsize">gsize</a> next_offset);</pre>
<p>
Освобождает связанный список блоков памяти структуры имеющей тип <em class="parameter"><code>type</code></em>.
Блоки памяти должны быть одинакового размера, распределённые через
<a href="glib-Memory-Slices.html#g-slice-alloc"><code class="function">g_slice_alloc()</code></a> или 
<a href="glib-Memory-Slices.html#g-slice-alloc0"><code class="function">g_slice_alloc0()</code></a>
и связаны вместе указателем <em class="parameter"><code>next</code></em> 
(также как в <a href="glib-Singly-Linked-Lists.html#GSList"><span class="type">GSList</span></a>). 
Смещение поля <em class="parameter"><code>next</code></em> передаётся в каждый блок как третий аргумент.
Помните что существующее поведение может быть изменено с помощью переменной окружения
<a href="glib-running.html#G_DEBUG">G_DEBUG=gc-friendly</a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>block_size</code></em>&#160;:</span></td>
<td>размер блоков
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>mem_chain</code></em>&#160;:</span></td>
<td>указатель на первый блок в цепочке
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>next_offset</code></em>&#160;:</span></td>
<td>поле смещения <em class="parameter"><code>next</code></em> в блоках
</td>
</tr>
</tbody>
</table></div>
<p>Начиная с версии 2.10


</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2881200"></a><h3>
<a name="g-slice-new"></a>g_slice_new()</h3>
<a class="indexterm" name="id2881215"></a><pre class="programlisting">#define     g_slice_new(type)</pre>
<p>
Удобный макрос для распределения блоков памяти из распределителя слайсов.
Он вызывает <a href="glib-Memory-Slices.html#g-slice-alloc"><code class="function">g_slice_alloc()</code></a> с 
sizeof (<em class="parameter"><code>type</code></em>) и приводит возвращаемый указатель к указателю данного типа, 
избегая приведения типа в исходном коде.
Помните что основной механизм распределения слайсов может быть изменён с помощью переменной окружения
<a href="glib-running.html#G_SLICE">G_SLICE=always-malloc</a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>type</code></em>&#160;:</span></td>
<td>тип для распределения, обычно имя структуры
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td>указатель на распределённый блок, приведённый к указателю <em class="parameter"><code>type</code></em>.
</td>
</tr>
</tbody>
</table></div>
<p>Начиная с версии 2.10

</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2881300"></a><h3>
<a name="g-slice-new0"></a>g_slice_new0()</h3>
<a class="indexterm" name="id2881315"></a><pre class="programlisting">#define     g_slice_new0(type)</pre>
<p>
Удобный макрос для распределения блока памяти из распределителя слайсов и установки памяти в 0. 
Он вызывает <a href="glib-Memory-Slices.html#g-slice-alloc0"><code class="function">g_slice_alloc0()</code></a> 
с sizeof (<em class="parameter"><code>type</code></em>) и приводит возвращаемый указатель к указателю полученного типа, 
избегая приведения указателя в исходном коде.
Помните что основной механизм распределения слайсов может быть изменён с помощью переменной окружения
<a href="glib-running.html#G_SLICE">G_SLICE=always-malloc</a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>type</code></em>&#160;:</span></td>
<td> тип для распределения, обычно имя структуры
</td>
</tr>
<tr>
<td><span class="term"><span class="emphasis"><em>Возвращает</em></span>&#160;:</span></td>
<td> указатель на распределённый блок, приведённый к указателю <em class="parameter"><code>type</code></em>.
</td>
</tr>
</tbody>
</table></div>
<p>Начиная с версии 2.10

</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2881400"></a><h3>
<a name="g-slice-free"></a>g_slice_free()</h3>
<a class="indexterm" name="id2881414"></a><pre class="programlisting">#define     g_slice_free(type, mem)</pre>
<p>
Удобный макрос для освобождения блока памяти который был распределён из распределителя слайсов. 
Он вызывает <a href="glib-Memory-Slices.html#g-slice-free1"><code class="function">g_slice_free1()</code></a> 
используя <code class="literal">sizeof (type)</code> как размер блока.
Помните что существующее поведение может быть изменено с помощью переменной окружения
<a href="glib-running.html#G_DEBUG">G_DEBUG=gc-friendly</a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>type</code></em>&#160;:</span></td>
<td>тип блока для освобождения, обычно имя структуры
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>mem</code></em>&#160;:</span></td>
<td>указатель на блок для освобождения
</td>
</tr>
</tbody>
</table></div>
<p>Начиная с версии 2.10

</p>
</div>
<hr>
<div class="refsect2" lang="en">
<a name="id2881495"></a><h3>
<a name="g-slice-free-chain"></a>g_slice_free_chain()</h3>
<a class="indexterm" name="id2881510"></a><pre class="programlisting">#define     g_slice_free_chain(type, mem_chain, next)</pre>
<p>
Освобождает связанный список блоков памяти структуры имеющей тип <em class="parameter"><code>type</code></em>.
Блоки памяти должны быть одинакового размера, распределены через 
<a href="glib-Memory-Slices.html#g-slice-alloc"><code class="function">g_slice_alloc()</code></a> или 
<a href="glib-Memory-Slices.html#g-slice-alloc0"><code class="function">g_slice_alloc0()</code></a> и связаны вместе указателем 
<em class="parameter"><code>next</code></em> 
(так же как в <a href="glib-Singly-Linked-Lists.html#GSList"><span class="type">GSList</span></a>). 
Имя поля <em class="parameter"><code>next</code></em> в <em class="parameter"><code>type</code></em> помещают как третий аргумент.
Помните что существующее поведение может быть изменено с помощью переменной окружения
<a href="glib-running.html#G_DEBUG">G_DEBUG=gc-friendly</a>.
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><span class="term"><em class="parameter"><code>type</code></em>&#160;:</span></td>
<td> тип <em class="parameter"><code>mem_chain</code></em> блоков
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>mem_chain</code></em>&#160;:</span></td>
<td> указатель на первый блок цепочки
</td>
</tr>
<tr>
<td><span class="term"><em class="parameter"><code>next</code></em>&#160;:</span></td>
<td> имя поля следующего указателя в <em class="parameter"><code>type</code></em>
</td>
</tr>
</tbody>
</table></div>
<p>Начиная с версии 2.10


</p>
</div>
</div>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.id2880543" href="#id2880543">5</a>] </sup>
<a href="http://citeseer.ist.psu.edu/bonwick94slab.html" target="_top">[Bonwick94]</a> Jeff Bonwick, The slab allocator: 
Кэширующий объекты распределитель памяти ядра. USENIX 1994, и  
<a href="http://citeseer.ist.psu.edu/bonwick01magazines.html" target="_top">[Bonwick01]</a> Bonwick and Jonathan Adams, Magazines and vmem: 
Расширенное распределение слайсов для множества процессоров и произвольных ресурсов. USENIX 2001
</p></div>
</div>
</div>
</body>
</html>
