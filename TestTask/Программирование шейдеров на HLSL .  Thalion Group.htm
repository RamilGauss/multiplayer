<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head>
	<title>Программирование шейдеров на HLSL .: Thalion Group</title>
	
	<meta name="robots" content="INDEX,FOLLOW">
	<meta name="generator" content="Thalion Group portal">
	<meta name="keywords" content="Thalion Group, knowledge base">
	<meta name="description" content="Все что Вы хотели знать про IT">
	<meta name="MSSmartTagsPreventParsing" content="true">
	<meta http-equiv="distribution" content="global">
	<meta http-equiv="content-type" content="text/html; charset=windows-1251">
	<meta http-equiv="resource-type" content="document">
	<link rel="shortcut icon" href="http://www.thalion.kiev.ua/idx.php/147/810/article/favicon.ico">
	<link rel="stylesheet" type="text/css" href="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/green.css">

	<script src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/ga.js" async="" type="text/javascript"></script><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-8212189-2']);
  _gaq.push(['_setDomainName', 'thalion.kiev.ua']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
<meta name="google-site-verification" content="2ggNnRrW9hfsNf8RyuKXGaNNjJ3WegmUojYmt6FS4Cc">
<meta name="yandex-verification" content="7b6ddd24925cf82b">
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td width="100%">

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr>
<td class="lore_splash_header" align="left" valign="bottom" width="20%">
<a href="http://www.thalion.kiev.ua/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/logo.gif" alt="Thalion Group logo" align="middle" border="0" height="95" width="300"></a>
</td>
<td align="center" width="65%">


</td>
<td class="lore_top_buttons" align="right" valign="bottom" width="15%">
	
	
	&nbsp;&nbsp;

			<a class="lore_dark_link" href="http://www.thalion.kiev.ua/contact.php"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/contact.gif" alt="" align="middle" border="0"> Обратная связь</a>
	</td>
</tr>
</tbody></table>
<table cellpadding="0px" cellspacing="0px" width="100%"><tbody><tr><td width="50%">
<div class="lore_option_tab" style="text-align:right;line-height:18px">
	<form method="get" action="/search.php">
		Поиск <input class="lore_input" name="query" maxlength="100" size="30" type="text">&nbsp;<input name="submit" value="Go" class="lore_button" type="submit">
	</form></div>
</td>
<td width="50%">
	<div class="lore_option_tab" style="text-align:left">
		<div id="lester_menu">
		<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/green_down_arrow.gif"> Список категорий <img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/green_down_arrow.gif"> 
    <div>
									<a href="http://www.thalion.kiev.ua/idx.php/139/0/">..... GameDev</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/140/0/">.......... Game Design</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/141/0/">.......... Интервью</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/144/0/">............... Интервью с издателями</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/143/0/">............... Интервью с разработчиками</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/142/0/">.......... Общие вопросы</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/9/0/">.......... Программирование игр</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/147/0/">............... Direct3D</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/145/0/">............... Engine</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/148/0/">............... OpenGL</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/149/0/">............... Графика</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/151/0/">............... Звук</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/150/0/">............... Сети</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/146/0/">............... Экспорт</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/152/0/">.......... Разработка MMOG</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/16/0/">..... Hardware</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/93/0/">.......... Другие статьи</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/137/0/">.......... Интерфейсы передачи данных</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/92/0/">.......... Корпоративные инфраструктуры</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/90/0/">.......... Лазерные диски</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/87/0/">.......... Материнские платы, микропроцессоры</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/84/0/">.......... Мобильное...</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/91/0/">.......... Модемы</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/86/0/">.......... Мониторы</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/85/0/">.......... Ноутбуки</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/88/0/">.......... Оперативная память</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/89/0/">.......... Подсистемы хранения данных</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/107/0/">.......... Принтеры</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/94/0/">.......... Серверы и архитектуры</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/6/0/">..... Internet</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/138/0/">.......... ActiveX</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/119/0/">.......... ASP .NET</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/59/0/">.......... CGI</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/62/0/">.......... Flash</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/54/0/">.......... HTML</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/135/0/">.......... JavaScript</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/134/0/">.......... SEO</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/58/0/">.......... VBScript</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/55/0/">.......... VRML</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/61/0/">.......... web-дизайн</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/56/0/">.......... Web-сервисы</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/7/0/">.......... XML</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/63/0/">.......... Поиск в Internet</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/8/0/">.......... Протоколы</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/111/0/">.......... Разное</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/95/0/">.......... Серверы</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/96/0/">..... IT-консалтинг</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/101/0/">.......... BPM - Business Performance Management</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/100/0/">.......... Business Intelligence</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/97/0/">.......... MRP- и ERP- системы</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/98/0/">.......... Автоматизация бизнес-процессов</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/102/0/">.......... Другие статьи</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/99/0/">.......... Корпоративные сайты и порталы</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/103/0/">.......... Стандарт CobiT</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/13/0/">..... Security</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/51/0/">.......... Безопасность в Интернет</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/136/0/">.......... Буква закона</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/52/0/">.......... Вирусы и другой вредоносный код</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/53/0/">.......... Защита Web сайтов</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/49/0/">.......... Криптография</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/50/0/">.......... Статьи, обзоры, книги</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/131/0/">.......... Технологии взлома</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/11/0/">..... Software Engineering</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/29/0/">.......... CASE-технологии</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/31/0/">.......... Middleware</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/117/0/">.......... Programming Stone по-русски</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/113/0/">.......... Методологии разработки ПО</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/114/0/">............... Экстремальное программирование (XP)</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/110/0/">.......... Проектирование и моделирование</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/32/0/">.......... Средства разработки приложений</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/30/0/">.......... Тестирование</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/28/0/">.......... Управление качеством</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/27/0/">.......... Управление проектами</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/4/0/">..... Алгоритмы</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/127/0/">.......... АИ, ГА, Нейронные сети</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/124/0/">.......... Графика</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/129/0/">.......... Игры</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/120/0/">.......... Математика</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/130/0/">............... Вычислительная геометрия</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/123/0/">.......... Поиск. Строки и последовательности</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/125/0/">.......... Разбор выражений. Компиляторы и интерпретаторы.</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/128/0/">.......... Разное</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/126/0/">.......... Сжатие и кодирование</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/121/0/">.......... Сортировка</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/122/0/">.......... Структуры данных</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/12/0/">..... Базы данных</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/109/0/">.......... Access</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/37/0/">.......... Cache'</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/38/0/">.......... Clarion</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/39/0/">.......... DB2</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/40/0/">.......... FoxPro</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/41/0/">.......... Informix</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/42/0/">.......... InterBase</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/43/0/">.......... MS SQL Server</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/44/0/">.......... MySQL</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/45/0/">.......... Oracle</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/46/0/">.......... Postgres (PostgreSQL)</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/47/0/">.......... Sybase</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/35/0/">.......... Дайджесты</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/48/0/">.......... ЛИНТЕР</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/34/0/">.......... Статьи</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/36/0/">.......... Учебные пособия и обзоры</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/5/0/">..... Другое</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/15/0/">..... Операционные системы</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/81/0/">.......... BeOS</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/77/0/">.......... FreeBSD</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/76/0/">.......... Linux</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/79/0/">.......... Netware</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/78/0/">.......... OpenBSD</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/80/0/">.......... OS/2</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/75/0/">.......... Unix</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/74/0/">.......... Windows</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/106/0/">............... Windows 2003 Server</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/132/0/">.......... Windows Mobile</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/83/0/">.......... Виртуальные машины</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/82/0/">.......... Другие операционные системы</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/73/0/">.......... Теория</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/10/0/">..... Программирование</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/21/0/">.......... Assembler</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/112/0/">............... Прерывания</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/115/0/">.......... C#</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/108/0/">.......... C++ Builder</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/17/0/">.......... C/C++</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/118/0/">............... QT</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/18/0/">.......... Delphi/Pascal</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/19/0/">.......... Java</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/22/0/">.......... Perl</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/23/0/">.......... PHP</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/24/0/">.......... Python</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/20/0/">.......... Visual Basic</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/25/0/">.......... Защита программного обеспечения</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/116/0/">.......... Оптимизация</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/26/0/">.......... Программирование для встроенных систем</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/14/0/">..... Сети</a>	
															<a href="http://www.thalion.kiev.ua/idx.php/70/0/">.......... ATM</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/71/0/">.......... Netware</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/69/0/">.......... xDSL</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/65/0/">.......... Беспроводные технологии</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/72/0/">.......... Дайджесты и статьи по сетевым технологиям</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/66/0/">.......... Локальные сети</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/67/0/">.......... Сетевое оборудование</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/68/0/">.......... Сети хранения данных</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/64/0/">.......... Учебные пособия и обзоры</a>	
												<a href="http://www.thalion.kiev.ua/idx.php/133/0/">..... Стандарты</a>	
									<a href="http://www.thalion.kiev.ua/idx.php/104/0/">..... Юмор</a>	
				</div>
	</div>
	</div>
</td></tr></tbody></table>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr>
	<td class="lore_left_panel" valign="top" width="180">
		<div class="lore_category_tree_base"><a href="http://www.thalion.kiev.ua/">Thalion Group</a></div>
										<div class="lore_category_tree_category"><a style="padding-left:10px;" href="http://www.thalion.kiev.ua/idx.php/139/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;GameDev</a></div>
				
															<div class="lore_category_tree_category"><a style="padding-left:20px;" href="http://www.thalion.kiev.ua/idx.php/140/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Game Design</a></div>
				
									<div class="lore_category_tree_category"><a style="padding-left:20px;" href="http://www.thalion.kiev.ua/idx.php/141/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Интервью</a></div>
				
													<div class="lore_category_tree_category"><a style="padding-left:20px;" href="http://www.thalion.kiev.ua/idx.php/142/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Общие вопросы</a></div>
				
									<div class="lore_category_tree_category"><a style="padding-left:20px;" href="http://www.thalion.kiev.ua/idx.php/9/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Программирование игр</a></div>
				
															<div class="lore_category_tree_current_category"><a style="padding-left:30px;" href="http://www.thalion.kiev.ua/idx.php/147/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow_down.gif" alt="" border="0">&nbsp;Direct3D</a></div>
				
									<div class="lore_category_tree_category"><a style="padding-left:30px;" href="http://www.thalion.kiev.ua/idx.php/145/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Engine</a></div>
				
									<div class="lore_category_tree_category"><a style="padding-left:30px;" href="http://www.thalion.kiev.ua/idx.php/148/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;OpenGL</a></div>
				
									<div class="lore_category_tree_category"><a style="padding-left:30px;" href="http://www.thalion.kiev.ua/idx.php/149/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Графика</a></div>
				
									<div class="lore_category_tree_category"><a style="padding-left:30px;" href="http://www.thalion.kiev.ua/idx.php/151/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Звук</a></div>
				
									<div class="lore_category_tree_category"><a style="padding-left:30px;" href="http://www.thalion.kiev.ua/idx.php/150/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Сети</a></div>
				
									<div class="lore_category_tree_category"><a style="padding-left:30px;" href="http://www.thalion.kiev.ua/idx.php/146/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Экспорт</a></div>
				
												<div class="lore_category_tree_category"><a style="padding-left:20px;" href="http://www.thalion.kiev.ua/idx.php/152/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Разработка MMOG</a></div>
				
												<div class="lore_category_tree_category"><a style="padding-left:10px;" href="http://www.thalion.kiev.ua/idx.php/16/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Hardware</a></div>
				
													<div class="lore_category_tree_category"><a style="padding-left:10px;" href="http://www.thalion.kiev.ua/idx.php/6/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Internet</a></div>
				
													<div class="lore_category_tree_category"><a style="padding-left:10px;" href="http://www.thalion.kiev.ua/idx.php/96/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;IT-консалтинг</a></div>
				
													<div class="lore_category_tree_category"><a style="padding-left:10px;" href="http://www.thalion.kiev.ua/idx.php/13/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Security</a></div>
				
													<div class="lore_category_tree_category"><a style="padding-left:10px;" href="http://www.thalion.kiev.ua/idx.php/11/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Software Engineering</a></div>
				
													<div class="lore_category_tree_category"><a style="padding-left:10px;" href="http://www.thalion.kiev.ua/idx.php/4/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Алгоритмы</a></div>
				
													<div class="lore_category_tree_category"><a style="padding-left:10px;" href="http://www.thalion.kiev.ua/idx.php/12/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Базы данных</a></div>
				
													<div class="lore_category_tree_category"><a style="padding-left:10px;" href="http://www.thalion.kiev.ua/idx.php/5/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Другое</a></div>
				
									<div class="lore_category_tree_category"><a style="padding-left:10px;" href="http://www.thalion.kiev.ua/idx.php/15/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Операционные системы</a></div>
				
													<div class="lore_category_tree_category"><a style="padding-left:10px;" href="http://www.thalion.kiev.ua/idx.php/10/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Программирование</a></div>
				
													<div class="lore_category_tree_category"><a style="padding-left:10px;" href="http://www.thalion.kiev.ua/idx.php/14/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Сети</a></div>
				
													<div class="lore_category_tree_category"><a style="padding-left:10px;" href="http://www.thalion.kiev.ua/idx.php/133/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Стандарты</a></div>
				
									<div class="lore_category_tree_category"><a style="padding-left:10px;" href="http://www.thalion.kiev.ua/idx.php/104/0/"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/arrow.gif" alt="" border="0">&nbsp;Юмор</a></div>
				
			
		<noindex><div id="googleAd">
		
		<!-- Ukrainian Banner Network 120х60 START -->
<center><script>
//<!--
ubn_user = "50558";
ubn_page = "1";
ubn_pid = Math.round((Math.random() * (10000000 - 1)));
document.write("<iframe src='http://banner.kiev.ua/cgi-bin/bi.cgi?h" +
ubn_user + "&amp;"+ ubn_pid + "&amp;" + ubn_page + 
"&amp;4' frameborder=0 vspace=0 hspace=0 " +
" width=120 height=60 marginwidth=0 marginheight=0 scrolling=no>");
document.write("<a href='http://banner.kiev.ua/cgi-bin/bg.cgi?" +
ubn_user + "&amp;"+ ubn_pid + "&amp;" + ubn_page + "' target=_top>");
document.write("<img border=0 src='http://banner.kiev.ua/" +
"cgi-bin/bi.cgi?i" + ubn_user + "&amp;" + ubn_pid + "&amp;" + ubn_page +
"&amp;4' width=120 height=60 alt='Ukrainian Banner Network'></a>");
document.write("</iframe>");
//-->
</script><iframe src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/bi.htm" vspace="0" hspace="0" marginwidth="0" marginheight="0" frameborder="0" height="60" scrolling="no" width="120">&lt;a
 
href='http://banner.kiev.ua/cgi-bin/bg.cgi?50558&amp;amp;1587032&amp;amp;1'
 target=_top&gt;&lt;img border=0 
src='http://banner.kiev.ua/cgi-bin/bi.cgi?i50558&amp;amp;1587032&amp;amp;1&amp;amp;4'
 width=120 height=60 alt='Ukrainian Banner Network'&gt;&lt;/a&gt;</iframe><br>
</center>
<!-- Ukrainian Banner Network 120х60 END -->
<br>
<!-- Ukrainian Banner Network 120х600 START -->
<center><script>
//<!--
ubn_user = "50558";
ubn_page = "1";
ubn_pid = Math.round((Math.random() * (10000000 - 1)));
document.write("<iframe src='http://banner.kiev.ua/cgi-bin/bi.cgi?h" +
ubn_user + "&amp;"+ ubn_pid + "&amp;" + ubn_page + 
"&amp;8' frameborder=0 vspace=0 hspace=0 " +
" width=120 height=600 marginwidth=0 marginheight=0 scrolling=no>");
document.write("<a href='http://banner.kiev.ua/cgi-bin/bg.cgi?" +
ubn_user + "&amp;"+ ubn_pid + "&amp;" + ubn_page + "' target=_top>");
document.write("<img border=0 src='http://banner.kiev.ua/" +
"cgi-bin/bi.cgi?i" + ubn_user + "&amp;" + ubn_pid + "&amp;" + ubn_page +
"&amp;8' width=120 height=600 alt='Ukrainian Banner Network'></a>");
document.write("</iframe>");
//-->
</script><iframe src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/bi_002.htm" vspace="0" hspace="0" marginwidth="0" marginheight="0" frameborder="0" height="600" scrolling="no" width="120">&lt;a
 
href='http://banner.kiev.ua/cgi-bin/bg.cgi?50558&amp;amp;3987226&amp;amp;1'
 target=_top&gt;&lt;img border=0 
src='http://banner.kiev.ua/cgi-bin/bi.cgi?i50558&amp;amp;3987226&amp;amp;1&amp;amp;8'
 width=120 height=600 alt='Ukrainian Banner Network'&gt;&lt;/a&gt;</iframe><br>
</center>
<!-- Ukrainian Banner Network 120х600 END -->
		
		</div></noindex>
		
	</td>
	<td valign="top">
		<table width="100%">
		<tbody><tr>
		<td class="lore_breadcrumb" width="100%">
			<a href="http://www.thalion.kiev.ua/" class="lore_small_link">Thalion Group</a>
												.: <a href="http://www.thalion.kiev.ua/idx.php/139/0/" class="lore_small_link">GameDev</a>
																.: <a href="http://www.thalion.kiev.ua/idx.php/9/0/" class="lore_small_link">Программирование игр</a>
																.: <a href="http://www.thalion.kiev.ua/idx.php/147/0/" class="lore_small_link">Direct3D</a>
														.: <span class="lore_breadcrumb_current">Программирование шейдеров на HLSL</span>
									<center><script src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/index.htm" type="text/javascript"></script></center>
		</td>
		</tr>
		<tr>
		<td class="lore_content" width="*">
<!-- overLIB Code -->
<script type="text/javascript" src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/overlib.js"><!-- overLIB (c) Erik Bosrup --></script>
<div id="overDiv" style="position:absolute; visibility:hidden; z-index:1000;"></div>
<!-- End overLIB Code -->

<br>

<h2>Программирование шейдеров на HLSL</h2>

<table width="100%">
<tbody><tr>
<td valign="top" width="*">
	<div class="lore_article_content">
		<p align="left"><b class="title"><font color="#00304b" size="5">Вступление.</font></b> </p><p>Нынешнее
 графическое железо, такое, например, как GeForce FX5900 или Radeon9800 
предоставляет пользователю возможность замены некоторых частей 
графического конвейера шейдером. Шейдер — это специальная программа, 
которая использует определенные программируемые регистры видеокарты для 
создания различных графических эффектов. Более новые карты (GeForce 
6800) обеспечивают расширенные возможности программируемости шейдеров: 
огромное количество инструкций, динамическое ветвление и т.д. </p><p>Для
 начала немного теории. На рисунке показана упрощенная модель 
графического конвейера, которая условно делится на две части: обработка 
геометрии и обработка фрагментов. <br></p><p class="non" align="center"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510.jpg" border="0"> <br><i>Рисунок 1. Обработка геометрии.</i> </p><p>На
 первой стадии графического конвейера выполняется преобразование 
координат (применение мировой, видовой и проекционной матриц) вершины, 
перевод вершины в пространство отсечения, расчет освещения, применение 
материалов, определение цвета каждой вершины с учетом всех источников 
света и генерация текстурных координат. </p><p>После выполнения этих 
операций наступает компоновка примитива. В этой части конвейера, вершины
 группируются в треугольники и подаются в растеризатор. <br></p><p class="non" align="center"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_2.jpg" border="0"> <br><i>Рисунок 2. Обработка фрагментов.</i> </p><p>Растеризатор
 делит треугольник на фрагменты (пиксели), для которых интерполируются 
текстурные координаты и цвет. Затем для каждого фрагмента происходит 
выполнение следующих операций: проверка принадлежности пикселя, 
наложение текстур (заданные для фрагмента координаты текстуры определяют
 интерполированный цвет из элементов текстурного изображения — текселей,
 значение этого цвета комбинируется с цветом фрагмента), применение 
эффектов тумана, альфа-тест, тест шаблона (stencil-test), тест глубины, 
смешивание, дизеринг и логические операции. После обработки всех этих 
методов полученный фрагмент помещается в буфер кадра, который 
впоследствии выводиться на экран. </p><p>В каждую из этих частей 
графического конвейера можно вставить свой определенный шейдер. 
Существует два различных шейдера: вершинный шейдер (vertex shader) и 
пиксельный шейдер (pixel shader). </p><p><i>Вершинный шейдер</i> 
выполняется для каждой вершины (в данном контексте — это структура, 
состоящая из нескольких вершинных атрибутов, одним из которых должна 
быть позиция вершины), проходящей по графическому конвейеру, и его нужно
 установить в разделе обработки вершин. В нем можно изменять атрибуты, 
такие как нормаль, позиция, текстурные координаты, цвет вершины и т.д. 
Эти данные вершинный шейдер получает из вершинного буфера. <br>Во время 
использования вершинного шейдера следующие части графического конвейера 
не выполняются: трансформация из мирового пространства в пространство 
отсечения, нормализация, освещение и материалы, генерация текстурных 
координат. Соответственно и устанавливаемые render states тоже не будут 
оказывать никакого эффекта на вершинный шейдер. </p><p><i>Пиксельные шейдеры</i>
 в свою очередь предоставляют широкие возможности по обработке 
фрагментов. Они позволяют пользователю по шагам управлять процессом 
наложения текстур, определения глубины и вычисления цвета фрагментов. 
Что это дает? Во-первых, можно создавать в играх per-pixel lighting т.е.
 реальное освещение (в статье рассматриваются самые известные методы 
освещения). Во-вторых, позволяет создавать красивые эффекты с частицами 
(например, огонь, дым, капли дождя). И многое другое. </p><p>Пиксельные 
шейдеры выполняются для каждого фрагмента в фазе растеризации 
треугольников. Фрагмент (или пиксель) — точка, с оконными координатами, 
полученная растеризатором после выполнения над ней ряда операций. Проще 
говоря, результирующая точка буфере кадра, совокупность этих точек потом
 формирует изображение. Пиксельные шейдеры оперирует над фрагментами до 
заключительных стадий, т.е. до тестов глубины, альфы и stencil. Кстати, 
возможно в будущем и этими операциями будет управлять шейдер, кто знает…
 Пиксельный шейдер получает интерполированные данные (цвет, текстурные 
координаты) из вершинного шейдера.</p><p align="left"><b class="title"><font color="#00304b" size="5">Обзор HLSL.</font></b> </p><p></p><p class="non" align="right"><i>Tired of writing shaders in assembly language? <br>Try the high–level shader language! <br>SDK help (с)</i> </p><p>Один
 из наиболее серьёзных компонентов в DirectX® 9, который предоставляет 
программирование шейдеров на языке высокого уровня (похожий на язык C), 
является HLSL(High Level Shading Language), разработанный Microsoft. </p><p>Зачем
 нужен HLSL? Область применения языка программирования графики высокого 
уровня весьма широка. Такой язык облегчает разработку графических 
эффектов и создание впечатляющих графических приложений. Кроме того, 
использование HLSL повышает читаемость кода шейдера и снижает время 
разработки тяжелого алгоритма. Приведем пример фрагментного шейдера на 
asm–языке: <br></p><pre>ps_2_0
<br>def c0, 1, 1, 0.5, 0.5
<br>mov r0, c0
<br>mov oC0, r0</pre><p>и тоже самое на HLSL: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4 main(): COLOR0{
   return float4(1.0,1.0,0.5,0.5);
}
</pre></td></tr></tbody></table></div><p>Можно сделать вывод, что HLSL очень удобен и понятен. </p><p><b class="title"><font color="#00304b" size="5">Описание языка HLSL.</font></b> </p><p><b>Типы данных.</b> </p><p>HLSL поддерживает разнообразные типы данных: от простых скаляров до комплексных типов - векторов и матриц. </p><p><b><i>Скалярные типы:</i></b> <br></p><p class="non" align="center"></p><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="title"><table border="0" cellpadding="5" cellspacing="1" width="100%"><tbody><tr><td class="fon"><br><b>Тип</b></td><td class="fon"><b>Значение</b> <br></td></tr><tr><td class="fon">bool&nbsp; </td><td class="fon">true или false <br></td></tr><tr><td class="fon">int&nbsp; </td><td class="fon">32-bit signed integer <br></td></tr><tr><td class="fon">half&nbsp; </td><td class="fon">16-bit floating point value <br></td></tr><tr><td class="fon">float&nbsp; </td><td class="fon">32-bit floating point value <br></td></tr><tr><td class="fon">double&nbsp; </td><td class="fon">64-bit floating point value <br></td></tr></tbody></table></td></tr></tbody></table><p></p><p>Не
 все графические процессоры в настоящее время поддерживают определенные 
типы данных (кроме float, конечно же). Например, целые числа могут 
эмулироваться через тип float. </p><p><b><i>Векторные типы:</i></b> <br></p><pre>vector &lt;type, size&gt;</pre><p>— означает вектор размерностью size, и скалярным типом type. </p><p>Можно объявлять еще так: </p><p></p><pre>typeN</pre><p>– означает N компонентный вектор с данным типом type. Например: <br></p><pre>float4&nbsp; Vector;</pre><p>или тоже самое можно объявить так: <br></p><pre>float&nbsp; Vector[4];</pre><p>или <br></p><pre>vector &lt;float, 4&gt; Vector;</pre><p><b><i>Матрицы:</i></b> </p><p>Подобно скалярам и векторам, матрицы могут иметь все скалярные типы. <br></p><pre>typeMxN</pre><p>— матрица с типом type и размерностью M на N. <br></p><pre>matrix&lt;type, M,N&gt;</pre><p>— матрица с типом type и размерностью M на N. </p><p>Можно контролировать ориентацию: <br></p><pre>#pragma pack_matrix (row_major);</pre><p>Доступ к элементам и строкам матрицы: <br></p><pre>mat._m00, mat._11, mat [0][0]
<br>mat._m00_m01_m02_m03, mat [0]</pre><p><b><i>Переменные:</i></b> </p><p>Переменная
 может быть объявлена как static или extern. Любая нестатическая 
переменная (записывается с приставкой extern или без приставки), которая
 объявлена за шейдером, может быть изменена через API. Статическая 
переменная используется только шейдером и не управляется API.&nbsp; </p><p>Например: <br></p><pre>extern float a;
<br>const&nbsp; float b;
<br>static float c;
<br>float d;</pre><p>Переменные a и d должны выставляться через 
API-функцию Set*ShaderConstant*() и их может изменять шейдер. Переменная
 b тоже задается через Set*ShaderConstant*(), но шейдер не может 
изменить ее значение. И переменная c не задается через API, но может 
быть изменена в шейдере. </p><p><b><i>Инициализация переменных выполняется также как и на языке C.</i></b> </p><p>Например: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float2x2 mat = {1.0f, 0.0f, // ряд 1
                1.0f, 2.0f}; // ряд 2
float4 pos = {1.0f, 0.5f, 12.0f, 1.0f};
float f = 0.01f;
</pre></td></tr></tbody></table></div><p><b><i>Структуры:</i></b> </p><p>HLSL поддерживает структуры. Например: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>struct VS_OUTPUT
{
  float4 Pos;
  float3 View;
};
</pre></td></tr></tbody></table></div><p><br>Структуры могут быть приведены к/из скалярных величин, векторов, матриц и других структур. </p><p><b><i>Операторы</i></b> </p><p>Существуют операторы для следующих операций: <br></p><p class="non" align="center"></p><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="title"><table border="0" cellpadding="5" cellspacing="1" width="100%"><tbody><tr><td class="fon"><br><b>Операции</b></td><td class="fon"><b>Операторы</b> <br></td></tr><tr><td class="fon">Арифметические&nbsp; </td><td class="fon">-, +, *, /, % <br></td></tr><tr><td class="fon">Инкремент, декремент&nbsp; </td><td class="fon">++, -- <br></td></tr><tr><td class="fon">Логические&nbsp; </td><td class="fon">&amp;&amp;, ||, ?: <br></td></tr><tr><td class="fon">Унарные&nbsp; </td><td class="fon">!, -, + <br></td></tr><tr><td class="fon">Сравнения&nbsp; </td><td class="fon">&lt;, &gt;, &lt;=, &gt;=, ==, != <br></td></tr><tr><td class="fon">Назначение&nbsp; </td><td class="fon">=, -=, +=, *=, /= <br></td></tr><tr><td class="fon">Привидение типов&nbsp; </td><td class="fon">(тип) <br></td></tr><tr><td class="fon">Комма&nbsp; </td><td class="fon">, <br></td></tr><tr><td class="fon">Член структуры&nbsp; </td><td class="fon">. <br></td></tr><tr><td class="fon">Член массива&nbsp; </td><td class="fon">[индекс] <br></td></tr></tbody></table></td></tr></tbody></table><p></p><p>Оператор извлечения остатка деления (%) работает как с целыми числами, так и с числами с плавающей точкой. </p><p>Сравнение векторов производится покомпонентно. </p><p><b><i>Ветвление</i></b> <br></p><pre>if (expr) then statement [else statement]</pre><p><b><i>Циклы</i></b> <br></p><pre>do statement while (expr);
<br>while (expr) statement;
<br>for (expr1;expr2;expr3) statement</pre><p><b><i>Функции</i></b> </p><p>Похоже
 на функции в C, за исключением того, что не поддерживается рекурсия. 
Параметры функции могут быть семантически связаны с данными. </p><p><i>Некоторые математические инструкции, которые можно применять в HLSL:</i> <br></p><p class="non" align="center"></p><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="title"><table border="0" cellpadding="5" cellspacing="1" width="100%"><tbody><tr><td class="fon"><br><b>abs(x)</b>&nbsp; </td><td class="fon"><i>абсолютная величина (per-component).</i> <br></td></tr><tr><td class="fon"><b>acos(x)</b>&nbsp; </td><td class="fon"><i>возвращает арккосинус каждого компонента x. Каждый компонент должен быть в диапазоне [-1, 1].</i> <br></td></tr><tr><td class="fon"><b>asin(x)</b>&nbsp; </td><td class="fon"><i>возвращает арксинус каждого компонента x. Каждый компонент должен быть в диапазоне [-pi/2, pi/2].</i> <br></td></tr><tr><td class="fon"><b>atan(x)</b>&nbsp; </td><td class="fon"><i>возвращает арктангенс каждого компонента x. Каждый компонент должен быть в диапазоне [-pi/2, pi/2].</i> <br></td></tr><tr><td class="fon"><b>ceil(x)</b>&nbsp; </td><td class="fon"><i>Возвращает наименьшее целое число, которое больше чем или равно x.</i> <br></td></tr><tr><td class="fon"><b>cos(x)</b>&nbsp; </td><td class="fon"><i>Возвращает косинус x.</i> <br></td></tr><tr><td class="fon"><b>cosh(x)</b>&nbsp; </td><td class="fon"><i>Возвращает гиперболический косинус x.</i> <br></td></tr><tr><td class="fon"><b>ddx(x)</b>&nbsp; </td><td class="fon"><i>Возвращает частную производную x относительно screen-space x-координаты.</i> <br></td></tr><tr><td class="fon"><b>ddy(x)</b>&nbsp; </td><td class="fon"><i>Возвращает частную производную x относительно screen-space y-координаты.</i> <br></td></tr><tr><td class="fon"><b>degrees(x)</b>&nbsp; </td><td class="fon"><i>Конвертирование x с радианы в градусы.</i> <br></td></tr><tr><td class="fon"><b>distance(a, b)</b>&nbsp; </td><td class="fon"><i>Возвращает расстояние между двумя точками a и b.</i> <br></td></tr><tr><td class="fon"><b>dot(a, b)</b>&nbsp; </td><td class="fon"><i>Возвращает dot product двух векторов a и b.</i> <br></td></tr><tr><td class="fon"><b>floor(x)</b>&nbsp; </td><td class="fon"><i>Возвращает самое большое целое число, которое является меньше чем или равным x.</i> <br></td></tr><tr><td class="fon"><b>fwidth(x)</b>&nbsp; </td><td class="fon"><i>Возвращает abs(ddx(x))+abs(ddy(x)).</i> <br></td></tr><tr><td class="fon"><b>len(v)</b>&nbsp; </td><td class="fon"><i>Векторная длина.</i> <br></td></tr><tr><td class="fon"><b>length(v)</b>&nbsp; </td><td class="fon"><i>Возвращает длину вектора v.</i> <br></td></tr><tr><td class="fon"><b>lerp(a, b, s)</b>&nbsp; </td><td class="fon"><i>Возвращает a + s (b - a).</i> <br></td></tr><tr><td class="fon"><b>log(x)</b>&nbsp; </td><td class="fon"><i>Возвращает логарифм x.</i> <br></td></tr><tr><td class="fon"><b>log10(x)</b>&nbsp; </td><td class="fon"><i>Возвращает десятичный логарифм x.</i> <br></td></tr><tr><td class="fon"><b>mul(a, b)</b>&nbsp; </td><td class="fon"><i>Делает матричное умножение между a и b. </i><br></td></tr><tr><td class="fon"><b>normalize(v)</b>&nbsp; </td><td class="fon"><i>Возвращает нормализированный вектор v.</i> <br></td></tr><tr><td class="fon"><b>pow(x, y)</b>&nbsp; </td><td class="fon"><i>Возвращает xy.</i> <br></td></tr><tr><td class="fon"><b>radians(x)</b>&nbsp; </td><td class="fon"><i>Конвертирует x из градусов в радианы.</i> <br></td></tr><tr><td class="fon"><b>reflect(i, n)</b>&nbsp; </td><td class="fon"><i>Возвращает вектор отражения.</i> <br></td></tr><tr><td class="fon"><b>refract(i, n, eta)</b>&nbsp; </td><td class="fon"><i>Возвращает вектор преломления.</i> <br></td></tr><tr><td class="fon"><b>rsqrt(x)</b>&nbsp; </td><td class="fon"><i>Возвращает 1 / sqrt(x).</i> <br></td></tr><tr><td class="fon"><b>sin(x)</b>&nbsp; </td><td class="fon"><i>Возвращает синус x.</i> <br></td></tr><tr><td class="fon"><b>sincos(x, out s, out c)</b>&nbsp; </td><td class="fon"><i>Возвращает синус и косинус x.</i> <br></td></tr><tr><td class="fon"><b>sinh(x)</b>&nbsp; </td><td class="fon"><i>Возвращает гиперболический синус x</i> <br></td></tr><tr><td class="fon"><b>sqrt(x)</b>&nbsp; </td><td class="fon"><i>Возвращает квадратный корень(per-component).</i> <br></td></tr><tr><td class="fon"><b>step(a, x)</b>&nbsp; </td><td class="fon"><i>Возвращает (x = a) ? 1 : 0.</i> <br></td></tr><tr><td class="fon"><b>tan(x)</b>&nbsp; </td><td class="fon"><i>Возвращает тангенс x</i> <br></td></tr><tr><td class="fon"><b>tanh(x)</b>&nbsp; </td><td class="fon"><i>Возвращает гиперболический тангенс x</i> <br></td></tr></tbody></table></td></tr></tbody></table><p></p><p><b><i>Использование текстур во фрагментном шейдере.</i></b> </p><p>Если
 вы хотите использовать текстуры во фрагментном шейдере, то необходимо 
объявить extern переменную типа sampler. Фактически sampler определяет 
текстуру, с которой можно читать текущие значение цвета во фрагментном 
шейдере. Ниже описаны функции, которые возвращают цвет текстуры, исходя 
из заданных параметров: <br></p><p class="non" align="center"></p><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="title"><table border="0" cellpadding="5" cellspacing="1" width="100%"><tbody><tr><td class="fon"><br><b>tex1D(s, t)</b>&nbsp; </td><td class="fon"><i>Чтение из одномерной текстуры. s - sampler. t - скаляр.</i> <br></td></tr><tr><td class="fon"><b>tex1D(s, t, ddx, ddy)</b>&nbsp; </td><td class="fon"><i>Чтение из одномерной текстуры, с производными. s - sampler. <br>t, ddx, и ddy - скаляры.</i> <br></td></tr><tr><td class="fon"><b>tex1Dproj(s, t)</b>&nbsp; </td><td class="fon"><i>Чтение из одномерной проективной текстуры. s - sampler. t - 4D вектор. <br>t делиться на t.w перед выполнением функции.</i> <br></td></tr><tr><td class="fon"><b>tex1Dbias(s, t)</b>&nbsp; </td><td class="fon"><i>Чтение из одномерной текстуры со смещением, s - sampler, t - 4-х мерный вектор, <br>Мип-уровень смещается на t.w до того, как производится поиск. </i><br></td></tr><tr><td class="fon"><b>tex2D(s, t)</b>&nbsp; </td><td class="fon"><i>Чтение из двухмерной текстуры. s - sampler. t – 2D вектор. </i><br></td></tr><tr><td class="fon"><b>tex2D(s, t, ddx, ddy)</b>&nbsp; </td><td class="fon"><i>Чтение из двухмерной текстуры, с производными. s - sampler. <br>t – 2D текстурные координаты. ddx, ddy- 2D вектора. </i><br></td></tr><tr><td class="fon"><b>tex2Dproj(s, t)</b>&nbsp; </td><td class="fon"><i>Чтение из двумерной проективной текстуры. s - sampler. t - 4D вектор. <br>t делиться на t.w перед выполнением функции.</i> <br></td></tr><tr><td class="fon"><b>tex2Dbias(s, t)</b>&nbsp; </td><td class="fon"><i>Чтение из двумерной текстуры со смещением, s - sampler, t - 4-х мерный вектор, <br>Мип-уровень смещается на t.w до того, как производится поиск. </i><br></td></tr><tr><td class="fon"><b>tex3D(s, t)</b> </td><td class="fon"><i>Чтение из трехмерной текстуры. s - sampler. t – 3D вектор. </i><br></td></tr><tr><td class="fon"><b>tex3D(s, t, ddx, ddy)</b>&nbsp; </td><td class="fon"><i>Чтение из трехмерной текстуры, с производными. s - sampler. <br>t – 2D текстурные координаты. ddx, ddy - 3D вектора. </i><br></td></tr><tr><td class="fon"><b>tex3Dproj(s, t)</b>&nbsp; </td><td class="fon"><i>Чтение из трехмерной проективной текстуры. s - sampler. t - 4D вектор. <br>t делиться на t.w перед выполнением функции.</i> <br></td></tr><tr><td class="fon"><b>tex3Dbias(s, t)</b>&nbsp; </td><td class="fon"><i>Чтение из трехмерной текстуры со смещением, s - sampler, <br>t - 4-х мерный вектор, Мип-уровень смещается на t.w до того, как производится поиск. <br></i></td></tr><tr><td class="fon"><b>texCUBE(s, t)</b>&nbsp; </td><td class="fon">[i]Чтение из кубической текстуры. s – sampler, <br>t – 2D текстурные координаты. <br></td></tr><tr><td class="fon"><b>texCUBE(s, t, ddx, ddy)</b>&nbsp; </td><td class="fon"><i>Чтение из кубической текстуры. s - sampler. <br>t – 3D текстурные координаты. ddx, ddy - 3D вектора.</i> <br></td></tr><tr><td class="fon"><b>texCUBEproj(s, t)</b>&nbsp; </td><td class="fon"><i>Чтение из кубической проективной текстуры. s – sampler, t - 4D вектор. <br>t делиться на t.w перед выполнением функции.</i> <br></td></tr><tr><td class="fon"><b>texCUBEbias(s, t)</b>&nbsp; </td><td class="fon"><i>Чтение из кубической текстуры. s – sampler, t - 4D вектор. <br>Мип-уровень смещается на t.w до того, как производится поиск.</i> <br></td></tr></tbody></table></td></tr></tbody></table><p></p><p><i>t – текстурные координаты. ddx, ddy – производные.</i> </p><p>Есть полезное свойство констант в HLSL это связывание с регистрами констант, например: <br></p><pre>sampler tex : register (s0);</pre><p>Определяет текстуру в 0 stage. А в API это задается так: <br></p><pre>RenderDevice-&gt;SetTexture(0,texture0);</pre><p><b>Входные и исходящие параметры вершинного и фрагментного шейдеров.</b> </p><p>Вершинные и фрагментные шейдера имеют два типа входящих данных: varying и uniform. </p><p><i>Uniform</i>
 — данные, которые постоянны для многократного использования в шейдере. 
Объявление uniform данных в HLSL можно сделать двумя способами: </p><p>1)Объявить данные как extern переменную. Например: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre><font color="#0054cf">float</font> f;

float4 main () : COLOR
{
  <font color="#0054cf">return</font> f;
}</pre></td></tr></tbody></table></div><p>2)Объявить данные через определитель uniform. Например: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4 main (uniform float4 f) : COLOR
{
  <font color="#0054cf">return</font> f;
}</pre></td></tr></tbody></table></div><p><i>Uniform</i> переменные задаются через таблицу констант. Таблица констант содержит все регистры, которые постоянно используются в шейдере. </p><p><i>Varying</i>
 — данные, которые являются уникальными для каждого вызова шейдера. 
Например: позиция, нормаль и т.д. В вершинном шейдере такая семантика 
описывает varying данные, которые передаются из вершинного буфера, а во 
фрагментом шейдере — интерполированные данные, полученные из вершинного 
шейдера. Основные входящие семантические типы: <br></p><p class="non" align="center"></p><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="title"><table border="0" cellpadding="5" cellspacing="1" width="100%"><tbody><tr><td class="fon"><br><b>POSITIONn</b>&nbsp; </td><td class="fon"><i>Позиция.</i> <br></td></tr><tr><td class="fon"><b>BLENDWEIGHTn</b>&nbsp; </td><td class="fon"><i>Весовой коэффициент</i> <br></td></tr><tr><td class="fon"><b>BLENDINDICESn</b>&nbsp; </td><td class="fon"><i>Индекс весовой матрицы</i> <br></td></tr><tr><td class="fon"><b>NORMALn</b>&nbsp; </td><td class="fon"><i>Нормаль.</i> <br></td></tr><tr><td class="fon"><b>PSIZEn</b>&nbsp; </td><td class="fon"><i>Размер точки.</i> <br></td></tr><tr><td class="fon"><b>COLORn</b>&nbsp; </td><td class="fon"><i>Цвет.</i> <br></td></tr><tr><td class="fon"><b>TEXCOORDn</b>&nbsp; </td><td class="fon"><i>Текстурные координаты.</i> <br></td></tr><tr><td class="fon"><b>TANGENTn</b>&nbsp; </td><td class="fon"><i>Тангент.</i> <br></td></tr><tr><td class="fon"><b>BINORMALn</b>&nbsp; </td><td class="fon"><i>Бинормаль.</i> <br></td></tr><tr><td class="fon"><b>TESSFACTORn</b>&nbsp; </td><td class="fon"><i>Фактор тесселяции.</i> <br></td></tr></tbody></table></td></tr></tbody></table><p></p><p>Использование <i>varying</i> данных во фрагментном шейдере определяет состояние одного фрагмента. Основные входящие семантические типы: <br></p><p class="non" align="center"></p><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="title"><table border="0" cellpadding="5" cellspacing="1" width="100%"><tbody><tr><td class="fon"><br><b>COLORn</b>&nbsp; </td><td class="fon"><i>Цвет.</i> <br></td></tr><tr><td class="fon"><b>TEXCOORDn</b>&nbsp; </td><td class="fon"><i>Текстурные координаты.</i> <br></td></tr></tbody></table></td></tr></tbody></table><p></p><p>n – определяет номер семантического типа. Например: <b>TEXCOORD1, NORMAL0</b>. </p><p>Исходящие
 данные шейдера определяют способ линковки с входящими данными 
следующего этапа графического конвейера. Например, исходящая семантика 
для вершинного шейдера связывает исходящие данные с интерполянтами в 
растеризаторе, который генерирует входящие данные для фрагментного 
шейдера. </p><p>Исходящие данные для вершинного шейдера: <br></p><p class="non" align="center"></p><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="title"><table border="0" cellpadding="5" cellspacing="1" width="100%"><tbody><tr><td class="fon"><br><b>POSITION</b>&nbsp; </td><td class="fon"><i>Позиция.</i> <br></td></tr><tr><td class="fon"><b>PSIZE</b>&nbsp; </td><td class="fon"><i>Размер точки.</i> <br></td></tr><tr><td class="fon"><b>FOG</b>&nbsp; </td><td class="fon"><i>Коэффициент “туманности” для вершины.</i> <br></td></tr><tr><td class="fon"><b>COLORn</b>&nbsp; </td><td class="fon"><i>Цвет.</i> <br></td></tr><tr><td class="fon"><b>TEXCOORDn</b>&nbsp; </td><td class="fon"><i>Текстурные координаты.</i> <br></td></tr></tbody></table></td></tr></tbody></table><p></p><p>Исходящие данные для фрагментного шейдера: <br></p><p class="non" align="center"></p><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="title"><table border="0" cellpadding="5" cellspacing="1" width="100%"><tbody><tr><td class="fon"><br><b>COLORn</b>&nbsp; </td><td class="fon"><i>Цвет.</i> <br></td></tr><tr><td class="fon"><b>DEPTH</b>&nbsp; </td><td class="fon"><i>Значение глубины.</i> <br></td></tr></tbody></table></td></tr></tbody></table><p></p><p>Теперь,
 когда мы обсудили синтаксис языка и связывание с графическим конвейером
 входящих/исходящих данных шейдеров, напишем простой пример на HLSL.</p><p align="left"><b class="title"><font color="#00304b" size="5">Dizzy эффект.</font></b> </p><p>Первый
 эффект, который мы рассмотрим, называется dizzy (с английского — 
головокружительный). Смысл эффекта заключается в отображении 
анимированных спирально-закрученных колец. </p><p><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_3.png" border="0"> </p><p>Алгоритм для вершинного шейдера: <br>1) Применяем видовую, мировую и проекционную матрицы на позицию вершины. <br>2)
 Сохраняем в текстурные координаты (TEXCOORD0) позицию 
нетрансформированной вершины для фрагментного шейдера. Т.е. входящими 
данными у нас будут: POSITION, а исходящими - TEXCOORD0. </p><p>Алгоритм для фрагментного шейдера: <br>1) Получаем интерполированные данные (TEXCOORD0 – т.е. наши текстурные координаты). <br>2) Вычисляем арктангенс между текстурными координатами x,y. <br>3) Вычисляем радиус между текстурными координатами. По уравнению окружности: <br>R<sup>2</sup>=(x-a)<sup>2</sup>+(y-b)<sup>2</sup>. Для удобства примем a = 0, b = 0. <br>4)
 Возвращаем цвет, по общей формуле sin(угол + радиус). Т.е. некое 
смещение, которое из-за функции синуса будет закручивать кольца. </p><p>Для
 того, что бы получить анимированную картинку необходимо еще ввести 
параметр time, который своим приростом (или наоборот, что повлияет на 
направление вращения) будет закручивать кольца. Еще можно ввести 
параметр num_ring, который определяет количество закручиваемых колец. 
Его надо умножить на радиус, ведь чем больше значение радиуса, тем 
больше расстояние между кольцами. </p><p>При подстановке этих параметров конечная формула примет вид: <br></p><pre>цвет=sin(угол + количество колец * радиус + время).</pre><p>Вот фрагментный шейдер этого эффекта: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4 main(float2 texCoord: TEXCOORD0) : COLOR
{
   <font color="#0054cf">float</font> ang = atan2 (texCoord.x, texCoord.y);
   <font color="#0054cf">float</font> rad = dot (texCoord, texCoord);

   <font color="#0054cf">return</font> 0.5*(1 + sin (ang + rings * rad + time));
};</pre></td></tr></tbody></table></div><p>И вершинный шейдер: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4x4 mvp;
<font color="#889988">//Структура для исходящих данных. Эти данные будут передаваться в растеризатор,</font>
<font color="#889988">// а потом во фрагментный шейдер.</font>
<font color="#0054cf">struct</font> VS_OUTPUT 
{
   float4 Pos: POSITION;
   float2 TexCoord: TEXCOORD0; 
};
<font color="#889988">//Для входящих данных нам нужна только позиция объекта, которая задается в вершинном буфере.</font>
VS_OUTPUT main(float4 Pos: POSITION)
{
   VS_OUTPUT Out;
   <font color="#889988">//применение видовой, мировой и проекционной матрицы на позицию вершины</font>
   Out.Pos = mul(mvp,Pos);
   <font color="#889988">//Приравниваем координаты вершины в текстурные координаты.</font>
   Out.TexCoord = normalize(Pos.xy);
   <font color="#0054cf">return</font> Out;
}</pre></td></tr></tbody></table></div><p>В качестве более трудных примеров рассмотрим модели освещения.</p><p align="left"><b class="title"><font color="#00304b" size="5">Модели освещения.</font></b> </p><p>Наверное,
 каждый слышал о моделях освещения, они окружают нас повсюду: например, 
возьмем любой объект, тот же стакан, стоящий на столе. На него падает 
некий свет, если по точнее, то свет от солнца или любого другого 
источника освещения, это и называется некоторой моделью освещения. На 
практике обычно никто не пытаются запрограммировать все физические 
принципы света, поскольку их вычисление очень дорого обходится. Однако 
придумано множество моделей дающих реалистичный результат при малых 
расчетах. </p><p>Рассмотрим все подробнее, создадим простую модель освещения — равномерное освещение. </p><p><b class="title"><font color="#00304b" size="5">1. Равномерное освещение.</font></b> </p><p>Равномерное
 освещение (ambient lighting) обеспечивает постоянное начальное 
освещение для всей сцены. Оно освещает все вершины объектов одинаково, 
потому что не зависит ни от каких других факторов освещения. Это самый 
простой и быстрый тип освещения, но при этом дает наименее реалистичный 
результат. Формула для вычисления этой модели освещения так же очень 
проста, т.к. там всего одна арифметическая операция — умножение. Для ее 
вычисления достаточно перемножить цвет материала на интенсивность 
освещения. </p><p><b>I<sub>ambient</sub>=k<sub>a</sub>&#215;I<sub>a</sub></b> </p><p>Вершинный шейдер для расчета равномерной модели освещения: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>//Произведение мировой, видовой и проекционной матриц.
float4x4 mat_mvp;
// Входящие данные.
struct VS_INPUT_STRUCT
{
  float4 position: POSITION;
};
// Исходящие данные.
struct VS_OUTPUT_STRUCT
{
  float4 position: POSITION;
};

VS_OUTPUT_STRUCT main (VS_INPUT_STRUCT In_struct)
{
  VS_OUTPUT_STRUCT Out_struct;
  Out_struct.position = mul (mat_mvp, In_struct.position);
  return Out_struct;
}
</pre></td></tr></tbody></table></div><p>Этот простейший шейдер просто 
вычисляет позицию объекта в мировом пространстве, но в данной модели 
освещения можно его и не использовать, поскольку от вершины нам не надо 
каких то других компонентов (нормаль и т.д.) для расчета. <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4 ambient_color;     // Цвет материала.
float  ambient_intensity; // Интенсивность цвета.

float4 main(): COLOR0
{
    // Возвратим Результат из формулы AI*AC. 
    return ambient_color * ambient_intensity;                            
}
</pre></td></tr></tbody></table></div><p>Здесь тоже нет ничего сложного,
 просто возвращаем компилятору произведение вектора, на какое то число в
 данном случае ambient_intensity. Делает он это так: <br></p><pre>ambient_intensity * ambient_color.x;
<br>ambient_intensity * ambient_color.y;
<br>ambient_intensity * ambient_color.z;
<br>ambient_intensity * ambient_color.w;</pre><p>Модель равномерного освещения: <br></p><p class="non" align="center"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_4.png" border="0"> </p><p>Для того чтобы вычислить бликовый и диффузный компоненты света, необходимо найти три вектора: <br>• Нормаль N к фрагменту. <br>• Видовой вектор V — вектор, который направлен на наблюдателя. <br>• Позицию источника света L. <br></p><p class="non" align="center"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_5.jpg" border="0"> </p><p>Углы между этими векторами составляют интенсивность освещения. </p><p><b class="title"><font color="#00304b" size="5">2. Диффузная модель освещения.</font></b> </p><p>Диффузная
 модель освещения (diffuse lighting model) — модель освещения, которая 
зависит от положения источника освещения и от объектной нормали 
поверхности. Поскольку излучение света одинаково во всех направлениях, 
видовой вектор не имеет значения, т.е. v=0. Такой метод требует большего
 вычисления, так как изменяется для каждой вершины объекта, однако 
неплохо затеняет объекты и придает им объем. Свет падает, не заполняя 
всю поверхность одинаковым цветом (как в случае с раномерным 
освещением), а создается впечатление, что, свет направлен на какую либо 
поверхность. <br></p><p class="non" align="center"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_6.jpg" border="0"> </p><p>Если
 вектор позиции источника освещения перпендикулярен поверхности, то 
никакой матовости не будет наблюдаться, потому что интенсивность света 
зависит от угла &#945;. Для расчета диффузной модели освещения используется 
формула (по закону Ламберта): </p><p><b>I<sub>diffuse</sub>=k<sub>d</sub>&#215;I<sub>d</sub>&#215;(<font style="TEXT-DECORATION: overline">N</font>•<font style="TEXT-DECORATION: overline">L</font>)</b> </p><p>Подведем итоги – создадим шейдеры для расчета освещения. </p><p>Вершинный шейдер: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4x4 mat_mvp;  //Произведение мировой, видовой и проекционной матриц.
float4x4 mat_world; //Мировая матрица.
float4   vec_light; //Позиция источника света

struct VS_INPUT_STRUCT //Входящие данные
{
    float4 position: POSITION;
    float3 normal:   NORMAL;
};

struct VS_OUTPUT_STRUCT //Исходящие данные
{
     float4 position: POSITION;
     float3 light:    TEXCOORD0;
     float3 normal:   TEXCOORD1;
};

VS_OUTPUT_STRUCT main(VS_INPUT_STRUCT In_struct)
{
    VS_OUTPUT_STRUCT Out_struct;
    //Вычисляем позицию вершины.
    Out_struct.position = mul(mat_mvp,In_struct.position);
    //Сохраняем позицию источника для передачи во фрагментный шейдер в виде
    //3D текстурных координат.
    Out_struct.light    = vec_light;
    //Рассчитываем нормаль поверхности и сохраняем для фрагментного шейдера.
    Out_struct.normal   = normalize(mul(mat_world,In_struct.normal));
    //*под словом “сохраняем” имеется ввиду посылание данных в растеризатор,
    //а только потом в вершинный шейдер.
    return Out_struct;
}
</pre></td></tr></tbody></table></div><p>И пиксельный шейдер: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float diffuse_intensity;
float4 diffuse_color;

float4 main(float3 light:  TEXCOORD0, float3 normal: TEXCOORD1):COLOR0
{
    return diffuse_color * diffuse_intensity * dot(normal,light);
}
</pre></td></tr></tbody></table></div><p>Диффузная модель освещения: <br></p><p class="non" align="center"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_7.gif" border="0"> </p><p><b class="title"><font color="#00304b" size="5">3.Бликовая модель освещения.</font></b> </p><p>Сложно,
 представить такую модель освещения не увидев ее. А на самом деле эту 
модель мы можем увидеть почти везде. Например, чисто отполированную 
(круговыми движениями) прямую металлическую поверхность, направив на нее
 источник света, и посмотрев под неким углом, который не перпендикулярен
 поверхности. В результате мы увидим блики на поверхности, которые 
существенно увеличивают реалистичность изображения. Эти блики являются 
отражением источника света от поверхности. В этой модели освещения 
помимо векторов позиции источника освещения и нормали (как в случае с 
диффузной моделью освещения) используются еще два вектора: видовой 
вектор и вектор отражения. Бликовую модель освещения (specular lighting 
model) предложил Буи-Туонг Фонг. <br></p><p class="non" align="center"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_8.jpg" border="0"> </p><p>Угол
 между видовым вектором и вектором отражения – &#946;. Чем больше угол &#946;, тем
 ярче бликовое освещение. Поэтому бликовая модель освещения вычисляется 
по следующей формуле: </p><p><b>I<sub>specular</sub>=k<sub>s</sub>&#215;I<sub>s</sub>&#215;(<font style="TEXT-DECORATION: overline">V</font>•<font style="TEXT-DECORATION: overline">R</font>)<sup>n</sup></b> <br></p><p class="non" align="left">где <font style="TEXT-DECORATION: overline">R</font>=reflect (–norm(<font style="TEXT-DECORATION: overline">V</font>), <font style="TEXT-DECORATION: overline">N</font>) <br>n — коэффициент яркости свечения. </p><p>Зависимость яркости свечения от угла &#946;: <br></p><p class="non" align="center"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_9.gif" border="0"> </p><p>С ростом параметра n отражение становиться все более бликовым и все более концентрируется вдоль направления вектора отражения <font style="TEXT-DECORATION: overline">R</font>. </p><p>Вершинный шейдер: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4x4 mat_mvp;      //Произведение мировой, видовой и проекционной матриц.
float4x4 mat_world;    //Мировая матрица.
float4   vec_light;    //Позиция источника света
float3   vec_view_pos; //Видовой вектор
float4   vec_eye;      //Позиция наблюдателя

struct VS_INPUT_STRUCT //Входящие данные
{
    float4 position: POSITION;
    float3 normal:   NORMAL;
};

struct VS_OUTPUT_STRUCT //Исходящие данные
{
    float4 position:  POSITION;
    float3 light:     TEXCOORD0;
    float3 normal:    TEXCOORD1;
    float3 view:      TEXCOORD2;
};

VS_OUTPUT_STRUCT main(VS_INPUT_STRUCT In_struct)
{
    VS_OUTPUT_STRUCT Out_struct;
    //Трансформируем позицию вершины
    Out_struct.position = mul(mat_mvp,In_struct.position);    
    //Сохраняем позицию источника для передачи в пиксельный шейдер в виде
    //3D текстурных координат.
    Out_struct.light = vec_light; 
    //Рассчитываем нормаль поверхности и сохраняем для пиксельного шейдера.
    Out_struct.normal = normalize(mul(mat_world,In_struct.normal));  
    //Вычисляем видовой вектор и сохраняем для пиксельного шейдера.
    Out_struct.view = vec_eye - vec_view_pos;

    return Out_struct;
}
</pre></td></tr></tbody></table></div><p><br>Необязательно вычислять 
видовой вектор в шейдере, можно вычислить в программе и занести в 
вершинный шейдер. Для этого нужно инвертировать видовую матрицу и 
умножить на вектор D3DXVECTOR4(0.0,0.0,0.0,1.0) — позиция при которой 
вектор перпендикулярен поверхности (смотрит на нас). Выглядит это так: <br></p><pre>D3DXMATRIXA16 mat_temp,mat_view_inverse;
<br>D3DXVECTOR4&nbsp; view_pos;
<br>mat_temp = mat_world * mat_view;
<br>D3DXMatrixInverse(&amp;mat_view_inverse,NULL,&amp;mat_temp);
<br>D3DXVec4Transform(&amp;view_pos,(D3DXVECTOR4*)&amp;D3DXVECTOR4(0.0f,0.0f,0.0f,1.0f));</pre><p>Пиксельный шейдер: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4 specular_color;
float4 specular_intensity;

struct PS_INPUT_STRUCT
{
    float3 light:  TEXCOORD0;
    float3 normal: TEXCOORD1;
    float3 view:   TEXCOORD2;
};

float4 main(PS_INPUT_STRUCT In):COLOR0
{
  float power =16;
  float3 reflect_vec=reflect(-normalize(In.view),In.normal);
  return specular_color*specular_intensity*pow(dot(reflect_vec, In.light),power);
}
</pre></td></tr></tbody></table></div><p>Бликовая модель освещения: <br></p><p class="non" align="center"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_10.png" border="0"> </p><p><b class="title"><font color="#00304b" size="5">Модификация бликового освещения по Блинну.</font></b> </p><p>Джим
 Блинн придумал альтернативный способ вычисления бликового освещения, 
который устраняет дорогие вычисления над вектором отражения. Он ввел 
промежуточный вектор, который является средним значением между видовым 
вектором и вектором позиции источника освещения: <b><font style="TEXT-DECORATION: overline">H</font>=(<font style="TEXT-DECORATION: overline">L</font>+<font style="TEXT-DECORATION: overline">V</font>)/(|<font style="TEXT-DECORATION: overline">L</font>+<font style="TEXT-DECORATION: overline">V</font>|)</b> </p><p>Общая формула имеет вид: </p><p><b>I<sub>blin_specular</sub>=k<sub>b_s</sub>&#215;I<sub>b_s</sub>&#215;(<font style="TEXT-DECORATION: overline">N</font>•<font style="TEXT-DECORATION: overline">H</font>)<sup>n</sup></b> </p><p>Поэтому фрагментный шейдер уже будет такой: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4 main(PS_INPUT_STRUCT In_struct):COLOR0
{
  float3 H=normalize(In.light+In.view);
  float n = 16;
  return specular_color*specular_intensity*pow(dot(In.normal,H),n);
}
</pre></td></tr></tbody></table></div><p><b class="title"><font color="#00304b" size="5">Ускорение вычисления яркости свечения.</font></b> </p><p>Шлик предложил замену степени n. Пусть скалярное произведение равно D: <i>D=(<font style="TEXT-DECORATION: overline">N</font>•<font style="TEXT-DECORATION: overline">H</font>)<sup>n</sup></i>, тогда по его способу яркость свечения будет вычисляться следующим образом: <br><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_12.gif" border="0"> </p><p>Пиксельный шейдер: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4 main(PS_INPUT_STRUCT In_struct):COLOR0
{
  float3 H=normalize(In.light+In.view);
  float n = 16;
  float D=dot(In.normal,H);
  return specular_color*specular_intensity*D/(n-D*n+D);
}
</pre></td></tr></tbody></table></div><p>Сравнительные графики степенных законов: <br></p><p class="non" align="center"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_13.gif" border="0"> </p><p>На
 самом деле физический смысл бликового отражения света намного сложнее, 
чем предполагается в модели освещения Фонга. В более реалистичной модели
 <b>I<sub>s</sub></b> зависит от длины волны <font style="FONT-FAMILY: Symbol">l</font> и от угла падения света (<font style="TEXT-DECORATION: overline">N</font>•<font style="TEXT-DECORATION: overline">L</font>). Такая зависимость называется коэффициентом Френеля. </p><p><b class="title"><font color="#00304b" size="5">Комбинирование компонентов освещения.</font></b> </p><p>Теперь
 мы можем сложить три модели освещения (постоянное, диффузное и 
бликовое), чтобы получить суммарное количество света I, получаемое 
глазом: <br><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_14.gif" border="0"> </p><p>Пиксельный шейдер теперь будет такой: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>struct PS_INPUT_STRUCT
{
    float3 light:  TEXCOORD0;
    float3 normal: TEXCOORD1;
    float3 view:   TEXCOORD2;
};

float4 ambient_color;     // Цвет материала.
float  ambient_intensity; // Интенсивность цвета.

float  diffuse_intensity;
float4 diffuse_color;

float4 specular_color;
float4 specular_intensity;

float n;

float4 main(PS_INPUT_STRUCT In_struct):COLOR0
{
  float3 H=normalize(In.light+In.view);
  float n = 16;
  float D= dot(In.normal,H);
  return ambient_color * ambient_intensity +
  diffuse_color * diffuse_intensity*dot(In.normal, In.light) +
  specular_color*specular_intensity*D/(n-D*n+D);
}
</pre></td></tr></tbody></table></div><p><b class="title"><font color="#00304b" size="5">Реалистичное освещение на основе Кука-Торренса</font></b> </p><p>В
 более реальных моделях освещения основное внимание уделяется на&nbsp; 
распределение энергии падающего света. Часть ее поглощается материалом и
 превращается в тепло, другая часть рассеивается в виде диффузного 
света, третья часть задает поверхности бликовую освещенность. Поэтому 
для различных материалов разделение падающего света происходит 
по-разному, и зависит оно от: <br>• Функции распределения нормалей <br>• Затенения и экранирования <br>• Коэффициента Френеля </p><p><i>Функция распределение нормалей</i> </p><p>Эта функция описывает возможное отклонение нормали к поверхности от идеальной нормали <font style="TEXT-DECORATION: overline">N</font>.
 Чем более эта функция пологая, тем большие отклонения допустимы и тем 
большей величины пятно отраженного блика. Необходимые нормали 
расположены вдоль вектора <font style="TEXT-DECORATION: overline">L</font>+<font style="TEXT-DECORATION: overline">V</font> и видимы в направлении <font style="TEXT-DECORATION: overline">V</font> и находятся под углом (<font style="TEXT-DECORATION: overline">H</font>•<font style="TEXT-DECORATION: overline">N</font>) к зрителю. Кук и Торренс использовали формулу распределения&nbsp; Бекмана: <br></p><p class="non" align="center"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_15.gif" border="0"> </p><p>где <font style="FONT-FAMILY: Symbol">d</font>=<font style="TEXT-DECORATION: overline">H</font>•<font style="TEXT-DECORATION: overline">N</font> <br>m – степень шероховатости объекта. 0.2f – гладкая поверхность, 0.6f – шероховатая. По умолчанию ставят 0.3f. </p><p>График распределения Бекмана: <br></p><p class="non" align="center"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_16.png" border="0"> </p><p><i>Затенение и экранирование</i> </p><p>В
 модели Кука–Торренса учитываются также и такие эффекты, как затенение 
(shadowing) и экранирование (masking), которые определяют интенсивность 
бликовой составляющей. </p><p>Неэкранированный свет равен: <br><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_17.gif" border="0"> </p><p>Незатененный свет равен: <br><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_18.gif" border="0"> </p><p>Тогда финальный множитель G равен: </p><p><b>G=min(1, G<sub>m</sub>, G<sub>s</sub>)</b> <br></p><p class="non" align="center"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_19.gif" border="0"> </p><p><i>Коэффициент Френеля</i> </p><p>Этот коэффициент определяет долю отраженного света и задается функцией: <br></p><p class="non" align="center"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_20.gif" border="0"> <br></p><p class="non">где <font style="FONT-FAMILY: Symbol">f</font> — угол падения, косинус, которого равен c=(<font style="TEXT-DECORATION: overline">N</font>•<font style="TEXT-DECORATION: overline">H</font>) <br><i>n</i> — показатель преломления материала, g=sqrt(<i>n</i><sup>2</sup>+c<sup>2</sup>–1) </p><p>В
 действительности, в шейдере мы будем использовать другую формулу для 
расчета коэффициента Френеля из-за ограниченности инструкций. Замену 
предложил Шлик: </p><p><b>F=R<sub>s</sub>+(1–R<sub>s</sub>)&#215;(1–<font style="TEXT-DECORATION: overline">E</font>•<font style="TEXT-DECORATION: overline">N</font>)<sup>n</sup></b> <br>где R<sub>s</sub> — бликовое отражение, <br><font style="TEXT-DECORATION: overline">E</font> — вектор наблюдателя, <br><font style="TEXT-DECORATION: overline">N</font> — нормаль из карты нормалей. </p><p>Такая аппроксимация не учитывает соответственно <font style="FONT-FAMILY: Symbol">f</font> и <i>n</i> компоненты, но имеет степень n, с увеличением которой можно добиться не плохих результатов. Шлик использовал n=5. </p><p><i>Комбинирование всех множителей</i> </p><p>Торренс и Спэрроу объединили эти множители и вывели формулу для подсчета бликового света: <br><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_21.gif" border="0"> </p><p>Знаменатель <font style="TEXT-DECORATION: overline">N</font>•<font style="TEXT-DECORATION: overline">V</font> введен для регулирования интенсивности света. <br></p><p class="non" align="center"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_23.jpg" border="0"> </p><p>Общая формула для расчета количества света такая: <br><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_22.gif" border="0"> </p><p>Пришлось формулу немного упростить, так как в оригинале каждый компонент освещения (кроме бликового) умножается еще и на F(0, <i>n</i>). Сделано это из-за использования аппроксимации Шлика. </p><p>Пиксельный шейдер этого эффекта: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float roughness;
sampler SAMP_COLOR;
sampler SAMP_BUMP;

struct PS_INPUT 
{
  float2 T : TEXCOORD0;
  float3 L : TEXCOORD1;
  float3 V : TEXCOORD2; 
  float3 H : TEXCOORD3;
};

float4 main(PS_INPUT IN): COLOR0
{
  float3 N = tex2D(SAMP_BUMP,IN.T);
  N = normalize(2.0f * N - 1.0f);
  IN.L = normalize(IN.L);
  IN.V = normalize(IN.V);
  IN.H = normalize(IN.H);

  float r2 = roughness * roughness;

  float exponent = -(1-dot(N,IN.H) * dot(N,IN.H))/(dot(N,IN.H) * dot(N,IN.H)*r2);

  float D = pow(2.71,exponent) /  (r2*dot(N,IN.H) * dot(N,IN.H)*dot(N,IN.H) * dot(N,IN.H));

  float F = pow(1 - dot(N,IN.V),5);

  float G = min(1, min(2.0f * dot(N,IN.H) / dot(IN.V,IN.H) * 
    dot(N,IN.L), 2.0f * dot(N,IN.H) / dot(IN.V,IN.H) * dot(N,IN.V)));

  float4 Spec = max(0.0f,(D*F*G) / (dot(N,IN.V) * 3.14));
  float4 Diff = max(0.0f,dot(N,IN.L));

  return tex2D(SAMP_COLOR,IN.T) * (Diff + Spec);
}
</pre></td></tr></tbody></table></div><p>И вершинный шейдер: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4x4 view_proj_matrix: register(c0);
float4x4 view_matrix;
float4 light_vec;
float4x4 inv_view_matrix;
float4 view_position;

struct VS_INPUT
{
  float4 mPosition : POSITION0; 
  float3 mNormal : NORMAL; 
  float2 mCoord : TEXCOORD0; 
  float3 mTangent : TANGENT; 
  float3 mBinormal : BINORMAL;
};

struct VS_OUTPUT
{
  float4 P: POSITION0;
  float2 T : TEXCOORD0; 
  float3 L : TEXCOORD1;
  float3 V : TEXCOORD2; 
  float3 H : TEXCOORD3;
};

VS_OUTPUT main(const VS_INPUT IN) 
{
  VS_OUTPUT OUT;
  OUT.P = mul(view_proj_matrix,IN.mPosition);
  OUT.T = IN.mCoord;
  OUT.L = float3(dot(light_vec,IN.mTangent),dot(light_vec,IN.mNormal),dot(light_vec,IN.mBinormal));
  OUT.V = float3(dot(view_position,IN.mTangent),
     dot(view_position,IN.mNormal),dot(view_position,IN.mBinormal));
  OUT.H = (OUT.L + OUT.V);
  return OUT;
}
</pre></td></tr></tbody></table></div><p align="left"><b class="title"><font color="#00304b" size="5">Specular Bump Mapping.</font></b> </p><p>Ну конечно, без этого никак :), хотелось бы рассказать про этот эффект… </p><p>Вот
 мы и подошли к более серьезным моделям освещения, нам придется 
рассчитать вектор освещения, создать неортогональную систему координат, и
 т.д. Для тех кто не знает что такое bump mapping, то выглядит он так: </p><p><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_24.png" border="0"> </p><p>Для
 реализации этого эффекта нам понадобиться две текстуры: base map и 
normal map, base map — это diffuse текстура, а normal map текстуру нам 
придется делать самим (почти самим). Для этого нужно скачать plug-in к 
Photoshop (На сайте nVidia есть этот plug-in), или любую другую 
программу которая конвертирует из height map в dot3. Или же 
воспользоваться программой normal mapper, которая находиться в Radeon DX
 SDK. Суть bump mapping’a состоит в том, чтобы сделать иллюзию 
выпуклости какой либо поверхности. Для bump mapping’а понадобиться 
tangent space. Вместо normal’и полигона мы будем брать normal map (dot3 
текстуру), а tangent и binormal нам понадобятся для расчета освещения. 
Еще одна трудность правильного bump mapping’a (specular bump mapping’a) 
состоит в том, что нужно рассчитывать tangent space (в математической 
литературе привычно называть tangent space касательное пространство). В 
этой системе координат normal будет осью z, binormal — y, и tangent — x.
 </p><p>Так выглядит tangent space для вершины полигона: <br></p><p class="non" align="center"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_25.gif" border="0"> </p><p>Для расчета нормалей и tangent в D3DX есть следующие функции: </p><p></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>D3DXComputeNormals(…)  
D3DXComputeTangent(…)</pre></td></tr></tbody></table></div><p>Так что давайте сначала сосчитаем normal и tangent: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>LPD3DXMESH ResultMesh,pMeshSysMem2,pMeshSysMem = NULL;

<font color="#889988">// dcl_position </font>
<font color="#889988">// dcl_normal</font>
<font color="#889988">// dcl_texcoord</font>
<font color="#889988">// dcl_tangent</font>

D3DVERTEXELEMENT9 decl[]=
{
<font color="#889988">//stream, offset, type, method, semantic type</font>
{0,0, D3DDECLTYPE_FLOAT3,D3DDECLMETHOD_DEFAULT,D3DDECLUSAGE_POSITION,0},
{0,12,D3DDECLTYPE_FLOAT2,D3DDECLMETHOD_DEFAULT,D3DDECLUSAGE_NORMAL,  0},
{0,24,D3DDECLTYPE_FLOAT3,D3DDECLMETHOD_DEFAULT,D3DDECLUSAGE_TEXCOORD,0},
{0,36,D3DDECLTYPE_FLOAT3,D3DDECLMETHOD_DEFAULT,D3DDECLUSAGE_TANGENT, 0},
D3DDECL_END()
};

m_pd3dDevice-&gt;CreateVertexDeclaration(decl,&amp;m_pDecl);

<font color="#889988">// Load mesh from .x</font>
d3d__AddMesh(m_pd3dDevice,m_strTorus,&amp;pMeshSysMem,D3DXMESH_SYSTEMMEM);    
<font color="#889988">// Clone SysMesh #1 into SesMesh #2.</font>
pMeshSysMem-&gt;CloneMesh(D3DXMESH_MANAGED,decl,m_pd3dDevice,&amp;pMeshSysMem2); 

D3DXComputeNormals(pMeshSysMem2,NULL); <font color="#889988">// compute the normals</font>
D3DXComputeTangent(pMeshSysMem2,0,0,0,TRUE,NULL); <font color="#889988">// compute tangent(u)</font>
                                                  <font color="#889988">// and later binormal (v)</font>

<font color="#889988">// New vertex declaration</font>
<font color="#889988">// dcl_position </font>
<font color="#889988">// dcl_normal</font>
<font color="#889988">// dcl_texcoord</font>
<font color="#889988">// dcl_tangent</font>

D3DVERTEXELEMENT9 decl2[]=
{
{0,0, D3DDECLTYPE_FLOAT4,D3DDECLMETHOD_DEFAULT,D3DDECLUSAGE_POSITION,0},
{0,12,D3DDECLTYPE_FLOAT2,D3DDECLMETHOD_DEFAULT,D3DDECLUSAGE_NORMAL,   0},
{0,24,D3DDECLTYPE_FLOAT3,D3DDECLMETHOD_DEFAULT,D3DDECLUSAGE_TEXCOORD, 0},
{0,36,D3DDECLTYPE_FLOAT3,D3DDECLMETHOD_DEFAULT,D3DDECLUSAGE_TANGENT,  0},
D3DDECL_END()
};

<font color="#889988">// Clone SysMesh into ResultMesh.</font>
pMeshSysMem2-&gt;CloneMesh(D3DXMESH_MANAGED,decl2,m_pd3dDevice,&amp;ResultMesh); 
    
SAFE_RELEASE(pMeshSysMem);
SAFE_RELEASE(pMeshSysMem2);</pre></td></tr></tbody></table></div><p>Шейдеры… </p><p>vertex shader <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4x4 m_matMVP;     <font color="#889988">// World * View * Projection</font>
float4x4 m_matWorld;   <font color="#889988">// World transposed</font>
float4   m_vLightPos;  <font color="#889988">// Light position</font>
float4   m_vViewPos;   <font color="#889988">// View position</font>

<font color="#0054cf">struct</font> VS_INPUT_STRUCT
{
    float4 position: POSITION;  <font color="#889988">// Vertex position</font>
    float3 normal:   NORMAL0;   <font color="#889988">// Vertex normal</font>
    float2 texcoord: TEXCOORD0; <font color="#889988">// Vertex texcoord</font>
    float3 tangent:  TANGENT;   <font color="#889988">// Tangent ( u ) </font>
    float3 binormal: BINORMAL;  <font color="#889988">// Binormal( v )</font>
};

<font color="#0054cf">struct</font> VS_OUTPUT_STRUCT
{
    float4 position: POSITION;  <font color="#889988">// Vertex position</font>
    float2 texcoord: TEXCOORD0; <font color="#889988">// Texture coordinates</font>
    float3 light:    TEXCOORD1; <font color="#889988">// Light vector</font>
    float3 view:     TEXCOORD2; <font color="#889988">// View vector</font>
};

VS_OUTPUT_STRUCT main(VS_INPUT_STRUCT In_struct)
{
    VS_OUTPUT_STRUCT Out_struct;
  
    Out_struct.position = mul(m_matMVP,In_struct.position);
    Out_struct.texcoord = In_struct.texcoord;
    
    float3x3 matTangentSpace; 
    
    <font color="#889988">// Calculate binormal</font>
    In_struct.binormal = cross(In_struct.tangent,In_struct.normal);

    matTangentSpace[0] = mul(m_matWorld,In_struct.tangent); <font color="#889988">// x</font>
    matTangentSpace[1] = mul(m_matWorld,In_struct.binormal);<font color="#889988">// y</font>
    matTangentSpace[2] = mul(m_matWorld,In_struct.normal);  <font color="#889988">// z</font>
 
    <font color="#889988">// Calculate light vector and move into tangent space</font>
    Out_struct.light.xyz = mul(matTangentSpace,m_vLightPos); 
    <font color="#889988">// Calculate view vector and move into tangent space</font>
    Out_struct.view = mul(matTangentSpace,m_vViewPos);
    
    <font color="#0054cf">return</font> Out_struct;
}</pre></td></tr></tbody></table></div><p>fragment shader <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4 m_vAmbient;
float4 m_vDiffuse;
float4 m_vSpec;
float4 m_vHelper;

sampler2D m_Base: <font color="#0054cf">register</font>(s0); <font color="#889988">// Base map</font>
sampler2D m_Bump: <font color="#0054cf">register</font>(s1); <font color="#889988">// Dot3 map</font>

float4 main(float2 texcoord: TEXCOORD0;
            float3 light:    TEXCOORD1;
            float3 view:     TEXCOORD2): COLOR0;
{
    float4 tx_base = tex2D(m_Base,texcoord); <font color="#889988">// Load base texture</font>
    float4 tx_bump = tex2D(m_Bump,texcoord); <font color="#889988">// Load bump texture</font>

    tx_bump = normalize((tx_bump * 2.0) – 1.0f);<font color="#889988">//Bias normal to range [-1,1]</font>
    
    float3 nrmd_light = normalize(light); <font color="#889988">// Normalize light</font>
    float3 nrmd_view  = normalize(view); <font color="#889988">// Normalize view</font>
     
    <font color="#889988">// Calculate reflect vector</font>
    float4 reflect_vec = reflect(nrmd_view,nrmd_light);
    <font color="#889988">// Normal dot light</font>
    float4 n_dot_l     = dot(tx_bump,nrmd_light);
    <font color="#889988">// Reflect dot view</font>
    float4 r_dot_v     = dot(reflect_vec,nrmd_view);

    <font color="#889988">// Calculate ambient model</font>
    float4 ambient = tx_base * m_vAmbient * m_vHelper.x; 
    <font color="#889988">// Calculate diffuse model</font>
    float4 diffuse = tx_base * m_vDiffuse * m_vHelper.y * max(N_dot_L,0.0f);
    <font color="#889988">// Calculate specular model</font>
    float4 spec    = m_vSpec * m_vHelper.z + pow(r_dot_v, m_vHelper.w);
    
    <font color="#889988">// Result lighting model</font>
    float4 light_m = ambient + diffuse + spec;
    
    <font color="#0054cf">return</font> light_m;
}</pre></td></tr></tbody></table></div><p>Теперь о переменных в шейдерах… <br>m_matMVP&nbsp; – ModelViewProjection matrix <br>m_matWorld&nbsp; – World matrix <br>m_vLightPos – Light position <br>m_vViewPos&nbsp; – View position <br>m_vAmbient&nbsp; – Ambient color <br>m_vDiffuse&nbsp; – Diffuse color <br>m_vSpec&nbsp; &nbsp; - Specular color <br>m_vHelper.x - Ambient intensity <br>m_vHelper.y – Diffuse intensity <br>m_vHelper.z – Specular intensity <br>m_vHelper.w – Specular exponent </p><p>Для работы примера достаточно установить все константы, например, так: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>If(m_hLocation = m_pVertShader-&gt;GetConstantByName(NULL,”Нужная константа”))
{ 
    <font color="#889988">// Здесь ставить константу.</font>
}</pre></td></tr></tbody></table></div><p align="left"><b class="title"><font color="#00304b" size="5">Wood Shader.</font></b> </p><p>Эффект заключается в генерировании древесной поверхности объекта. Вот так выглядит wood shader: </p><p><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_26.jpg" border="0"> <br><i>wood shader без освещения и с освещением.</i> </p><p>Для такого эффекта нам понадобится текстура, обработанная noise фильтром. Пример такой текстуры: </p><p><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_28.png" border="0"> </p><p>Древесная
 поверхность состоит из колец, оси которых постоянно меняются и как бы 
скачут взад-вперед между полосами. Такой эффект легко можно задать 
функцией остатка: Rings(R)=frac(R), <br>где R – радиус колец, который вычисляется между текстурными координатами x и y. <br><br>Алгоритм для фрагментного шейдера: </p><p>1)Рассчитываем вектор искривления линии (Wooble или Skew), который равен суме текстурных координат и цвета из noise текстуры. <br>float3 shade = pos + (tex2D(Noise,pos)); <br>Т.е. примерно получится что-то такое: <img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/20040510_27.png" border="0"> </p><p>2)Вычисляем длину вектора искривления линии: <br>float dist = length (shade); <br>В эту часть алгоритма также можно добавить некий параметр num, который задает количество линий: float dist = length(shade)*num; </p><p>3)Полученное
 значение dist осталось занести в основную функцию древесного шейдера: 
float main_color = frac(dist); И для придания натуральности древесной 
поверхности помножим main_color на коричневый цвет: <br>return main_color*float4(0.5,0.3,0.01,0); </p><p>Все
 бы хорошо, но без освещения такой эффект не смотрится. Добавим 
диффузионную модель освещения. Для этого помножим результирующий свет на
 формулу расчета диффузной освещенности: <br>return main_color*float4(0.5,0.3,0.01,0)*((diffuse_color * diffuse_intensity) *dot(normal, lt)); </p><p>Фрагментный шейдер: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4  ambient_color;
float   ambient_intensity;
float4  diffuse_color;
sampler noise_texture;
sampler line_color_texture;

float4 main (float2 coords : TEXCOORD0, float3 lt:  TEXCOORD1, float3 normal: TEXCOORD2) : COLOR
{
    float3 shade = pos + (tex2D(Noise,pos));
    float dist = length (shade);
    float main_color = frac(dist);
    return main_color*float4(0.5f,0.5f,0.01f,0.0f)*(( diffuse_color *
              diffuse_intensity)*dot(normal, lt));
}
</pre></td></tr></tbody></table></div><p>Алгоритм вершинного шейдера составляет точную копию алгоритма вершинного шейдера dizzy эффекта. <br>Вершинный шейдер: </p><p></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4x4 view_proj_matrix;
float4x4 view_matrix;
float4 light;

struct VS_OUTPUT
{
   float4 Pos       : POSITION;
   float2 TexCoords   : TEXCOORD0;
   float3 light   : TEXCOORD1;
   float3 normal   : TEXCOORD2;
};  


VS_OUTPUT main (float4 pos: POSITION, float3 normal: NORMAL)
{
   VS_OUTPUT Out = (VS_OUTPUT) 0; 
   Out.Pos = mul (view_proj_matrix,pos);
   //масштабирование текстурных координат.
   Out.TexCoords = pos/25;
   Out.light=light;
   Out.normal=normalize(mul(view_matrix,normal));
   return Out;
}
</pre></td></tr></tbody></table></div><p align="left"><b class="title"><font color="#00304b" size="5">Оптимизация кода.</font></b> </p><p><b>1. Не изобретайте колесо! Используйте intrinsic функции. Например:</b> </p><p>Неоптимизированный код: <br></p><pre>float DOT3(float3 v1,float3 v2)
<br>{
<br>&nbsp; return(v1.x * v2.x +v1.y * v2.y +v1.z * v2.z);
<br>}
<br>float v=DOT3(V,R);</pre><p>на выходе: <br></p><pre>mul r0.xy, v0, c0 
<br>add r0.w, r0.y, r0.x
<br>mad oPos, c0.z, v0.z, r0.w</pre><p>Используя dot3 вместо DOT3, на выходе получите такое: <br></p><pre>dp3 r0.w, v0, c1</pre><p><b>2. Всячески избегайте привидения типов и пытайтесь всегда выбрать необходимый тип. Например:</b> </p><p>Неоптимизированный код: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>sampler smth;
float4 main(float2 coor: TEXCOORD2) : COLOR
{
   float3 col=tex2D(smth, coor);
   return float4(col,0);
}
</pre></td></tr></tbody></table></div><p>на выходе: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>ps_2_0
def c0, 0, 0, 0, 0
dcl t2.xy
dcl_2d s0
texld r0, t2, s0
mov r0.w, c0.x
mov oC0, r0
</pre></td></tr></tbody></table></div><p>Оптимизированный код: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>sampler smth;
float4 main(float2 coor: TEXCOORD2) : COLOR
{
   float4 col=tex2D(smth, coor);
   return col;
}
</pre></td></tr></tbody></table></div><p>на выходе: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>ps_2_0
dcl t2.xy
dcl_2d s0
texld r0, t2, s0
mov oC0, r0
</pre></td></tr></tbody></table></div><p><b>3. Объединяйте скаляры в вектора. Таким образом, можно уменьшить число констант в вашем шейдере.</b> Например: </p><p>Неоптимизированный код: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float x, y;
float4 main (float4 pos :POSITION) : POSITION
{
  return (pos * x+y);
}
</pre></td></tr></tbody></table></div><p>на выходе: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>vs_2_0
dcl_position v0
mul r0, v0, c0.x
add oPos, r0, c1.x
</pre></td></tr></tbody></table></div><p>Оптимизированный код: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float2 vec;
float4 main (float4 pos :POSITION) : POSITION
{
  return (pos * vec.x + vec.y);
}
</pre></td></tr></tbody></table></div><p>на выходе: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>vs_2_0
dcl_position v0
mad oPos, v0, c0.x, c0.y
</pre></td></tr></tbody></table></div><p><b>4. Для ветвлений используйте тип bool как static.</b> Например: </p><p>Неоптимизированный код: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4 a;
bool b = true;
float4 main(float4 x: TEXCOORD0, float4 y : TEXCOORD1) : COLOR
{
  if(b)
    return  x+a;
  else
   return  y+a;
}
</pre></td></tr></tbody></table></div><p>на выходе: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>ps_2_0
dcl t0
dcl t1
add r1, t0, c0
add r0, t1, c0
cmp r0, -c1.x, r0, r1
mov oC0, r0
</pre></td></tr></tbody></table></div><p>Объявление переменной b как static намного оптимизирует выходной код: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>ps_2_0
dcl t0
add r0, t0, c0
mov oC0, r0
</pre></td></tr></tbody></table></div><p><b>5. Векторизируйте типы. Например:</b> </p><p>Неоптимизированный код: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4 main (float k: COLOR) : COLOR
{
  float a, b, c, d;
  a = k + 1;
  b = k + 2;
  c = k + 3;
  d = k + 4;
  return float4 (a, b, c, d);
}
</pre></td></tr></tbody></table></div><p>на выходе: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>ps 2_0
def c0, 1, 2, 3, 4
dcl v0.x
add r0.x, v0.x, c0.x
add r0.y, v0.x, c0.y
add r0.z, v0.x, c0.z
add r0.w, v0.x, c0.w
mov oC0, r0
</pre></td></tr></tbody></table></div><p>Оптимизированный код: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>float4 main(float k: COLOR) : COLOR
{
  float4 v;
  v = k + float4(1,2,3,4);
  return v;
}
</pre></td></tr></tbody></table></div><p>на выходе: <br></p><div class="code"><table cellpadding="5" cellspacing="2" width="100%"><tbody><tr><td><pre>ps_2_0
def c0, 1, 2, 3, 4
dcl v0.x
add r0, v0.x, c0
mov oC0, r0
</pre></td></tr></tbody></table></div><p><b class="title"><font color="#00304b" size="5">Завершение.</font></b> </p><p>Несколько советов: </p><p>Подсказка: <a href="http://www.gamedev.ru/tip/?id=74"><font color="#2e2e5c">В помощь программисту шейдеров.</font></a> <br>Рекомендуется скачать Render Monkey™ с сайта ATi Technologies®. <br>Программу Shader Works от Mad Software. <br>Подобную программу от NVIDIA® — FXComposer™. <br>Посетить сайт ShaderX <br>Fragment Level Phong Illumination: <a href="http://esprit.campus.luth.se/%7Ehumus/"><font color="#2e2e5c">http://esprit.campus.luth.se/~humus/</font></a>. <br>Еще серия статей: <a href="http://www.gamedev.net/columns/hardcore/"><font color="#2e2e5c">http://www.gamedev.net/columns/hardcore/</font></a> <br>Про ppl: <a href="http://www.dimensions3.host.sk/web/news.php"><font color="#2e2e5c">http://www.dimensions3.host.sk/web/news.php</font></a> <br>А так же: <a href="http://www.shadertech.com/"><font color="#2e2e5c">http://www.shadertech.com/</font></a> — есть ссылки на разные примеры. </p><p>P.S.
 По поводу API, каждый должен понимать, что все подобные эффекты можно 
сделать и на OpenGL, применяя при этом или GL_VERTEX/FRAGMENT PROGRAM 
либо на новом высокоуровневом языке GLSL или Cg. </p><p>Особую благодарность авторы выражают IronPeter'у.</p>
	</div>
</td>

<td valign="top" width="130">

			<table class="lore_article_info_box" width="100%">
		<tbody><tr>
		<td class="lore_article_info_box_label">
			Статья
		</td>
		<td class="lore_article_info_box_data">
			810
		</td>
		</tr>

		<tr>
		<td class="lore_article_info_box_label">
			Создана
		</td>
		<td class="lore_article_info_box_data">
			19-5-2008 
		</td>
		</tr>

		

				<tr>
		<td class="lore_article_info_box_label">
			Рейтинг
		</td>
		<td class="lore_article_info_box_data">
												<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/star.gif"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/star.gif"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/star.gif"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/star.gif"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/star.gif">
									</td>
		</tr>
				
		</tbody></table>
	
	
</td>
</tr>
</tbody></table>


<div style="text-align:center;margin-top:25px;">
	
		<a class="lore_dark_link" href="http://www.thalion.kiev.ua/email_article.php?article_id=810"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/email.gif" alt="" align="middle" border="0">  Email</a>
	&nbsp;&nbsp;
		<a class="lore_dark_link" href="#" onclick="window.open('/article.php?id=810&amp;action=print','print','statusbar=no,menubar=no,toolbar=no,scrollbars=yes,resizable=yes,width=800,height=600'); return false;"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/print.gif" alt="" align="middle" border="0"> Напечатать</a>

			&nbsp;&nbsp;
		<a class="lore_dark_link" href="http://www.thalion.kiev.ua/comment.php?article_id=810&amp;action=new"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/add_comment.gif" alt="" align="middle" border="0"> Добавить комментарий</a>
	</div>


	<br>
	<div style="text-align: center;">
	<a name="rate"></a>
	<form method="post" action="/rate.php">
			<small><i>Помогла ли Вам эта статья?</i></small>
			<select class="lore_input" name="rating">
				<option value="" selected="selected"></option>
				<option value="5">5 - Да, супер</option>
				<option value="4">4</option>
				<option value="3">3 - Кое что нашел</option>
				<option value="2">2</option>
				<option value="1">1 - Бред</option>
			</select>
			<input name="article_id" value="810" type="hidden">
			<input class="lore_button" name="submit" value="-&gt;" type="submit">
	</form>
	</div>


<div style="margin: 30px">
			<h3>Схожие статьи</h3>
		<div class="lore_content_box">
			<!-- FEATURED ARTICLES -->
			
<!-- REGULAR ARTICLES -->
		<div class="lore_article">

		<table width="100%">
		<tbody><tr>
		<td valign="top">
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/article.gif" alt="article">
		</td>
		<td valign="middle" width="100%">
			<a class="lore_normal_link" href="http://www.thalion.kiev.ua/idx.php/147/694/article/">Российский опыт внедрения парного программирования</a>
	
							<span class="lore_article_preview_font">
					<br>
					MAXKIR перевел статью Коуберна...
				</span>
						<br>
	
							<span class="lore_article_details_font">
									(No rating)&nbsp;
					
					3-8-2007
					&nbsp;&nbsp;
					Views: 5205
					&nbsp;&nbsp;
	
									</span>
			
		</td>
		</tr>
		</tbody></table>
	</div>
			<div class="lore_article">

		<table width="100%">
		<tbody><tr>
		<td valign="top">
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/article.gif" alt="article">
		</td>
		<td valign="middle" width="100%">
			<a class="lore_normal_link" href="http://www.thalion.kiev.ua/idx.php/147/693/article/">Парное программирование: преимущества и недостатки </a>
	
							<span class="lore_article_preview_font">
					<br>
					Original text at:...
				</span>
						<br>
	
							<span class="lore_article_details_font">
									(No rating)&nbsp;
					
					31-7-2007
					&nbsp;&nbsp;
					Views: 5878
					&nbsp;&nbsp;
	
									</span>
			
		</td>
		</tr>
		</tbody></table>
	</div>
			<div class="lore_article">

		<table width="100%">
		<tbody><tr>
		<td valign="top">
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/article.gif" alt="article">
		</td>
		<td valign="middle" width="100%">
			<a class="lore_normal_link" href="http://www.thalion.kiev.ua/idx.php/147/689/article/">Экстремальное программирование в действии</a>
	
							<span class="lore_article_preview_font">
					<br>
					Эпизод Экстремального...
				</span>
						<br>
	
							<span class="lore_article_details_font">
									(No rating)&nbsp;
					
					29-7-2007
					&nbsp;&nbsp;
					Views: 3853
					&nbsp;&nbsp;
	
									</span>
			
		</td>
		</tr>
		</tbody></table>
	</div>
		
		</div>
		
	<a name="comments"></a>
			<h3>Комментарии</h3>
		<div class="lore_content_box">
							<a class="lore_dark_link" href="http://www.thalion.kiev.ua/comment.php?article_id=810&amp;action=new"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/add_comment.gif" alt="" align="middle" border="0"> Добавить комментарий</a>
			
			<div class="lore_article_comments">
					К этой статье нет комментариев. 
			</div>
		</div>
	</div>

 	</td>
	</tr>
	</tbody></table>
</td>
</tr>
</tbody></table>

<br><br>
<div style="text-align: right; font-size: 10px;color:#999999;margin-right:25px;">

	<br>

	</div>

	<div style="margin-top: 10px; text-align: center;">
		©Thalion Group
		<br>
	</div>
<div valign="bottom" align="center">
<br>
<!--bigmir)net TOP 100-->
<script language="javascript" type="text/javascript" src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/bigmir.js"></script><script type="text/javascript" language="javascript" src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%88%D0%B5%D0%B9%D0%B4%D0%B5%D1%80%D0%BE%D0%B2%20%D0%BD%D0%B0%20HLSL%20.%20%20Thalion%20Group_files/a.js"></script><table style="display:inline;margin-right:4px;" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div style="margin:0px;padding:0px;font-size:1px;width:88px;"><div style="background:url('http://i.bigmir.net/cnt/samples/diagonal/b63_top.gif') no-repeat bottom;">&nbsp;</div><div style="font:10px Tahoma;background:url('http://i.bigmir.net/cnt/samples/diagonal/b63_center.gif');"><div style="text-align:center;"><a href="http://www.bigmir.net/" target="_blank" style="color:#0000ab;text-decoration:none;font:10px Tahoma;">bigmir<span style="color:#ff0000;">)</span>net</a></div><div style="margin-top:3px;padding: 0px 6px 0px 6px;color:#12351d;"><div style="float:left;font:10px Tahoma;">160</div><div style="float:right;font:10px Tahoma;">188</div></div><br clear="all"></div><div style="background:url('http://i.bigmir.net/cnt/samples/diagonal/b63_bottom.gif') no-repeat top;">&nbsp;</div></div></td></tr></tbody></table>
<noscript>
<img src="http://c.bigmir.net/?v131020&s131020&t2" width="88" height="31" alt="bigmir)net TOP 100" title="bigmir)net TOP 100" border="0" />
</noscript>
<!--bigmir)net TOP 100-->
</div>
<div valign="bottom" style="font-size: 9px;color:#000000;" align="center">
<br>
Реклама: 
</div>
</td></tr></tbody></table>



</body></html>